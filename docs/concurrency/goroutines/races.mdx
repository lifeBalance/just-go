import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'

import bankAccount from './code/bankaccount/main.go?raw'

# Race Conditions

A [race condition](https://en.wikipedia.org/wiki/Race_condition) is a software or hardware flaw occurring when **multiple threads or processes** access **shared data** concurrently, and the final outcome depends on the unpredictable timing or sequence of their execution. This often causes data corruption, system crashes, or security vulnerabilities.

## Creating a Race Condition

Consider the following code:

<Code code={bankAccount} lang="go" title="bankaccount/main.go" />

In this code, we do a few things:

- The `deposit` function, makes 1 million deposits of `10` bucks (total `10,000,000`).
- The `withdraw` function, makes 1 million withdraws of `10` bucks (total `10,000,000`).
- In `main`, we launch these two functions as goroutines, passing a pointer to the money.
- We use `sleep` for 2 seconds after creating the goroutines to wait for them to terminate. This is a temporary hack, until we introduce `WaitGroup`.

If we `go run bankaccount/main.go` you may get the following **output**:

```
Balance: 8459490
```

And if we run it several times:

```
Balance: 5821070
Balance: 9991960
Balance: -9993470
```

The `deposit` function should deposit a total of `10,000,000` bucks, whereas `withdraw` drains another `10,000,000` bucks. That should leave the bank account with the starting saldo of `100`, but that's not the case! Instead, we get different amounts, some of them even **negative**.

## What Happens During a Race

Depending on the order the goroutines interleave during that particular program run, the results may vary:


```
Time â”‚ Goroutine 1 (deposit)  â”‚ Goroutine 2 (withdraw) â”‚ money
â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€
  1  â”‚ READ (100)             â”‚                        â”‚ 100
  2  â”‚ ADD 10: 110            â”‚                        â”‚ 100
  3  â”‚                        â”‚ READ (100)             â”‚ 100
  4  â”‚                        â”‚ SUBTRACT 10: 90        â”‚ 100
  5  â”‚ WRITE 110.             â”‚                        â”‚ 110
  6  â”‚                        â”‚ WRITE money: 90        â”‚ 90  â† Lost deposit 10!
```

Both goroutines read `100`, but Goroutine 2's write **overwrites** Goroutine 1's deposit. The `+10` is lost! Imagine what can happen during the `1,000,000` iterations of the loop in each goroutine.

## Multiple Scenarios

When two goroutines access the same data simultaneously, their operations **interleave**, causing lost updates. Depending on timing, different interleavings produce different results:

```
Time â”‚ Goroutine 1 (deposit)  â”‚ Goroutine 2 (withdraw) â”‚ money
â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€
  1  â”‚                        â”‚ READ (100)             â”‚ 100
  2  â”‚                        â”‚ SUB 10 (90)            â”‚ 100
  3  â”‚ READ (100)             â”‚                        â”‚ 100
  4  â”‚                        â”‚ WRITE 90               â”‚ 90
  5  â”‚ ADD 10                 â”‚                        â”‚ 90
  6  â”‚ WRITE money: 110       â”‚                        â”‚ 110 â† Lost withdrawal 10!
```

The net result is that our program behaves erratically, in a non-deterministic way.

## Hardware

As we mentioned in a previous section, the Go scheduler doesn't guarantee order when several goroutines run concurrently. From a hardware point of view, the mismatches between the reading values, are related to stale data in outdated caches:

```
    GOROUTINE 1           GOROUTINE 2
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Go Runtime Scheduler        â”‚
â”‚  (Manages goroutines on OS threads) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                  â”‚
    OS THREAD 1         OS THREAD 2
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CPU Core 0   â”‚    CPU Core 1     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚   Cache   â”‚ â”‚   â”‚   Cache   â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            System Bus
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
          â”‚ Main Memory â”‚
          â”‚             â”‚
          â”‚   money: ?  â”‚ â† Shared variable
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

When goroutines run in different cores, we get **cache coherence delays**, where different cores may keep in their caches stale data. That being said, race conditions in Go happen because of interleaved operations on shared memory, not necessarily because goroutines run on different CPU cores. Even a **single CPU** core can cause race conditions if goroutines are **context-switched** in the middle of operations.

## Non-Preemptive Scheduling

In a [previous secction](/basic-concepts/scheduling#preemptive-scheduling) we saw how the **OS scheduler** uses [preemptive scheduling](https://en.wikipedia.org/wiki/Preemption_(computing)), meaning it would interrupt a running task and hand the CPU to another one, even if the running task hasnâ€™t blocked or yielded.

<Admonition title="User-level Threads">
Remember, goroutines or any **user-level threads**, are not managed by the **OS scheduler**.
</Admonition>


On the other hand, the **Go scheduler** (user-level scheduling) works in a **cooperative** (non-preemptive) way: it will only do a context switch if the task is blocking (slow I/O) or when the application calls a thread yield (`Gosched()` in Go).

<Admonition title="GOMAXPROCS">
The [runtime](https://pkg.go.dev/runtime) package includes a function named `GOMAXPROCS` which allows us to set the homonym **environment variable**. [GOMAXPROCS](https://go.dev/blog/container-aware-gomaxprocs) which allows us to set the maximum number of threads to use for running goroutines at once. 
</Admonition>

Knowing all the above, a solution to our program's **race condition** could be to set `GOMAXPROCS=1`, due to the **cooperative** way the Go scheduler works, our program would probably run one goroutine after another, in a **sequential way**. So if you add the following line in `main`:

```go
func main() {
	money := 100
	runtime.GOMAXPROCS(1) // ğŸ‘ˆ

	go deposit(&money)
	go withdraw(&money)

	time.Sleep(2 * time.Second) // âš ï¸ temporary hack

	fmt.Printf("Balance: %d\n", money)
}
```

If you run the program, the **output** will be:

```
Balance: 100
```

When we are running goroutines on a **single processor**, it is unlikely that the runtime will interrupt the execution in the middle of these instructions. For this reason, it's unlikely that any goroutine will see an outdated version of a variable, since all the goroutines will be running on the same processor, using the same caches.

```
 GOROUTINE 1           GOROUTINE 2
          â”‚                     â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚   Go Runtime Scheduler   â”‚
      â”‚ (Cooperative scheduling) â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
              OS THREAD 1
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚      CPU Core 0       â”‚
         â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
         â”‚   â”‚     Cache     â”‚   â”‚
         â”‚   â”‚               â”‚   â”‚
         â”‚   â”‚  money: 100   â”‚   â”‚ â† Single cache view
         â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           System Bus
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                     â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
              â”‚ Main Memory â”‚
              â”‚             â”‚
              â”‚  money: 100 â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```

Obviously, this is not a good solution to race conditions for several reasons:

- It would be equivalent to not using **concurrency** at all, giving up the advantage of having multiple processors.
- Also, because there is no guarantee that in a future version of Go, the scheduler chooses to work in a **preemptive** way, and then break our program.

## Atomic operations

The issue boils down to the way the statement `*money += 10` works. We're dealing with three separate operations:

- Read the value of `money`
- Update the value of `money`
- Write the value of `money`

At any point, any of these operations can interleave with the operations of the other goroutine (`*money -= 10`). Ideally we should turn these three steps into an [atomic operation](https://en.wikipedia.org/wiki/Linearizability).

<Admonition title="Atomic Operations">
An **atomic operation** is a sequence of instructions treated as a single, indivisible unit, ensuring it either completes entirely or fails entirely, with no intermediate state visible to other processes or threads.
</Admonition>

Turning a set of steps into an atomic operation means that the set of instructions must be executed without interference from other executions

## Proper Synchronization

Imagine two flatmates using an app to **add items** to a grocery list. At the moment the list contains the ingredients for a taco night:

- Tortilla
- Tomatoes
- Avocado
- Six-pack Coronas
- Two sombreros
- PiÃ±ata
- Baseball bat

They may end up buying the grocery list twice. But if we add **locking list** feature, so that when one of them enters the supermarket enables it, the other flatmate would know that someone is already doing the shopping, and wait for missing ingredients. To avoid **race conditions** in our programming, we need good **synchronization and communication** with the rest of the goroutines (flatmates) to make sure they donâ€™t step over each other.

## Detecting Race Conditions

Go ships with a [race detector](https://go.dev/doc/articles/race_detector) that we can enable with the `-race` flag. When the compiler sees that, it adds special code to all memory accesses to track when different goroutines are reading from and writing to memory. For example:

```go
go run -race bankaccount/main.go
==================
WARNING: DATA RACE
Read at 0x00c000010138 by goroutine 8:
...
```

When some race condition is detected, we get useful output about the reads from and writes to memory. Since this flag adds some overhead to our resulting binary, it's not advisable to use in production. Also, the detector may overlook some races if during that run the race hasn't happened, it's not perfect.