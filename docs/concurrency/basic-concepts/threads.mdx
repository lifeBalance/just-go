import Admonition from '@components/Admonition.astro'

# Threads

Many high-performance applications rely on threads to keep the UI responsive, overlap I/O with computation, and utilize all available CPU cores. When a **process** needs to perform **multiple tasks** at once, a common approach is to split those tasks across **threads**.  

```
┌──────────────────────────────┐
│        Process A             │
│ PID: 5102                    │  
│   ┌──── Memory Space ───┐    │       
│   │  Stack  │ Heap      │    │       
│   │  Data   │ Text      │    │       
│   └─────────────────────┘    │       
│   ┌── File Descriptors ─┐    │       
│   │ 0 stdin  1 stdout   │    │       
│   │ 2 stderr 3 socket#17│    │       
│   └─────────────────────┘    │  
│ ┌────────── Threads ───────┐ │
│ │ Main Thread (T0)         │ │
│ │ Worker Thread (T1)       │ │
│ │ Worker Thread (T2)       │ │
│ └──────────────────────────┘ │
└──────────────────────────────┘
```

A [thread](<https://en.wikipedia.org/wiki/Thread_(computing)>) is the actual unit of execution inside a process. Every process has at least one thread (the **main thread**), but it can create more.

<Admonition title="Threads are lighter than Processes">
Threads are lighter than processes, but they are still **not free**. An OS thread typically consumes about `1MB` of RAM just to exist.
</Admonition>

## Sharing is Caring

Unlike processes, threads inside the same process **share the same memory space**. This makes communication between them fast, but dangerous (two threads changing the same variable at once causes bugs).

```
┌───────────────────────────────────────────────────────┐
│                  Process PID 8204                     │
│ ┌────────────── Shared Memory Space ────────────────┐ │
│ │ ┌───────────────┐  ┌───────────────┐              │ │
│ │ │File Descript. │  │ Memory Space  │◄───────┐     │ │
│ │ └───────────────┘  └───────────────┘        │     │ │
│ │                                             │     │ │
│ │ ┌───────────── Thread T1 ────────────────┐  │     │ │
│ │ │ Stack        Registers     Program Ctr │  │     │ │
│ │ └────────────────────────────────────────┘  │     │ │
│ │ ┌───────────── Thread T2 ────────────────┐  │     │ │
│ │ │ Stack        Registers     Program Ctr │  │     │ │
│ │ └────────────────────────────────────────┘  │     │ │
│ │      both threads read/write shared memory ─┘     │ │
│ └───────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────┘
```

Threads share the process’s memory space, file descriptors, etc, so they can collaborate more easily than separate processes. For this reason, **thread-based concurrency** tends to be more lightweight than **inter-process communication**, but it also introduces the classic synchronization problems: race conditions, deadlocks, and so on.

## Multithreading

[Multithreading](https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)) allows a **single process** run multiple strands of execution **concurrently**. On multicore hardware those threads may run **in parallel**. Multithreading can be implemented at two different levels:

1. **Kernel-level threads**, where the operating system schedules and manages each thread directly.
2. **User-level threads**, where a runtime or library multiplexes **lightweight threads** inside the process on top of one or more **kernel threads**.

Each thread represents a **separate path of execution** inside the same process. Each thread has its own own stack, registers, and program counter. That means each can be at a different point in the code.

## User Level Threads

When a user launches an application, i.e. a process, this one receives its own **memory space**, which is different from the one used by the OS.

<Admonition title="A Context Switch">
  The term [user
  space](https://en.wikipedia.org/wiki/User_space_and_kernel_space) (or
  userland) refers to all code that runs outside the operating system's kernel.
</Admonition>

Application code can also make use threads. These threads are not managed by the OS; the OS only sees a **process** running, but doesn't have access to the threads running within that process. The process itself is responsible for managing them, and to this effect, must include a **scheduler**, which works pretty much the same as the OS scheduler, but at a smaller scale:

- Decide which thread should run.
- Maintain a table of the threads contexts.
- Perform **context switching**.

User-level threads are more performant, because context-switching at this level is faster. They introduce some **challenges** as well:

1. If a user-level thread performs some **blocking IO operation** (e.g. reading from a file), the OS scheduler may decide to deschedule the whole process (the OS only sees the **outer process**). As a result, the other threads running within, won't have a chance to run.

<Admonition title="Slow IO">
  One of the advantages of threads is to perform computations, when other
  threads are waiting for I/O.
</Admonition>

A way to avoid this issue is to use **non-blocking** IO operations, but not all devices support them.

2. Since the OS only sees the external process, the internal threads only have access to a processor's **single core** at a time. In other words, the **user-level threads** contained in that **kernel-level thread** will not be able to run in parallel.

