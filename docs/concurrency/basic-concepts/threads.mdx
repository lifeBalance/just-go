import Admonition from '@components/Admonition.astro'

# Threads

A [thread](<https://en.wikipedia.org/wiki/Thread_(computing)>) is the actual unit of execution inside a process. Every process has at least one thread (the **main thread**), but it can create more.

```
┌──────────────────────────────┐
│        Process PID 8204      │
│ ┌─────────── Memory ───────┐ │
│ │ Globals   Heap           │ │
│ └──────────────────────────┘ │
│ ┌────────── Threads ───────┐ │
│ │ Main Thread (T0)         │ │
│ │ Worker Thread (T1)       │ │
│ │ Worker Thread (T2)       │ │
│ └──────────────────────────┘ │
└──────────────────────────────┘
```

Unlike processes, threads inside the same process **share the same memory space**. This makes communication between them fast, but dangerous (two threads changing the same variable at once causes bugs).

<Admonition title="Threads are lighter than Processes">
Threads are lighter than processes, but they are still **not free**. An OS thread typically consumes about `1MB` of RAM just to exist.
</Admonition>

## Multithreading

When a **process** needs to perform **multiple tasks** at once, a common approach is to split those tasks across **threads**.  Many high-performance applications rely on threads to keep the UI responsive, overlap I/O with computation, and utilize all available CPU cores.

```
┌───────────────────────────────────────────────────────┐
│                  Process PID 8204                     │
│ ┌────────────── Shared Memory Space ────────────────┐ │
│ │ ┌───────────────┐  ┌───────────────┐              │ │
│ │ │   Global Data │  │     Heap      │◄───────┐     │ │
│ │ └───────────────┘  └───────────────┘        │     │ │
│ │                                             │     │ │
│ │ ┌───────────── Thread T1 ────────────────┐  │     │ │
│ │ │ Stack        Registers     Program Ctr │  │     │ │
│ │ └────────────────────────────────────────┘  │     │ │
│ │ ┌───────────── Thread T2 ────────────────┐  │     │ │
│ │ │ Stack        Registers     Program Ctr │  │     │ │
│ │ └────────────────────────────────────────┘  │     │ │
│ │      both threads read/write shared memory ─┘     │ │
│ └───────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────┘
```

Each thread represents a separate path of execution inside the same process. Each thread has its own own stack, registers, and program counter. That means each can be at a different point in the code.

<Admonition title="Multithreading">
In essence, [multi-threading](https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)) is the **OS-level mechanism** that lets a single process run multiple “strands” of execution concurrently (and in parallel, if there are multiple CPU cores). 
</Admonition>

Threads share the process’s memory space, file descriptors, etc, so they can collaborate more easily than separate processes. For this reason, thread-based concurrency tends to be more lightweight than inter-process communication, but it also introduces the classic synchronization problems: race conditions, deadlocks, and so on.

## Kernel Level Threads

Kernel-level threads are threads managed directly by the **operating system**. They execute within **processes**, but their scheduling and lifecycle are fully controlled by the OS.

The operating system maintains each thread’s **execution context** (registers, stack, and state) and uses this information when scheduling threads to run. Because the OS is aware of all threads, it decides when and whether each thread executes.

During a **context switch**, the operating system steps in to save the current thread’s context and selects the next thread to execute.

## User Level Threads

When a user launches an application, i.e. a process, this one receives its own **memory space**, which is different from the one used by the OS.

<Admonition title="A Context Switch">
  The term [user
  space](https://en.wikipedia.org/wiki/User_space_and_kernel_space) (or
  userland) refers to all code that runs outside the operating system's kernel.
</Admonition>

Application code can also make use threads. These threads are not managed by the OS; the OS only sees a **process** running, but doesn't have access to the threads running within that process. The process itself is responsible for managing them, and to this effect, must include a **scheduler**, which works pretty much the same as the OS scheduler, but at a smaller scale:

- Decide which thread should run.
- Maintain a table of the threads contexts.
- Perform **context switching**.

User-level threads are more performant, because context-switching at this level is faster. They introduce some **challenges** as well:

1. If a user-level thread performs some **blocking IO operation** (e.g. reading from a file), the OS scheduler may decide to deschedule the whole process (the OS only sees the **outer process**). As a result, the other threads running within, won't have a chance to run.

<Admonition title="Slow IO">
  One of the advantages of threads is to perform computations, when other
  threads are waiting for I/O.
</Admonition>

A way to avoid this issue is to use **non-blocking** IO operations, but not all devices support them.

2. Since the OS only sees the external process, the internal threads only have access to a processor's **single core** at a time. In other words, the **user-level threads** contained in that **kernel-level thread** will not be able to run in parallel.
