import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'

import bankAccount from './code/bankaccount/main.go?raw'


# Synchronization in Go

When multiple goroutines access **shared data** concurrently, we need **synchronization** to prevent race conditions. For example:

<Code code={bankAccount} lang="go" title="bankaccount/main.go" />

If we run the program above several times, we'll get different outputs:

```
Balance: 8459490
Balance: 5821070
Balance: 9991960
Balance: -9993470
```

In the [data races section](goroutines/races) we went into detail about why this was happening, but to summarize it: without synchronization, concurrent access to shared memory leads to **undefined behavior**, i.e. the program may work sometimes, fail other times, or produce incorrect results that are hard to debug.

<Admonition>
Synchronization ensures that operations on **shared resources** happen in a controlled, predictable manner—preventing data corruption and maintaining program correctness.
</Admonition>

In this section we'll explore ways of controlling and coordinating access to **shared data**, so that concurrency issues such as data races don't happen.

## Go Synchronization Primitives

Go offers several synchronization primitives (most of them in the [sync](https://pkg.go.dev/sync) package), each suited for different scenarios:

1. **Mutexes** (`sync.Mutex`) for protecting critical sections of code with mutual exclusion (Only one goroutine can hold the lock at a time).
2. **Channels** mechanism for communication between goroutines by passing messages.
3. **WaitGroups** (`sync.WaitGroup`) waiting for a set of goroutines to finish before proceeding.
3. **Read/Write Mutexes** (`sync.RWMutex`) are optimized locks that allow multiple readers OR one writer.
4. **Atomic Operations** (`sync/atomic`) are hardware-level atomic operations for simple values (integers, pointers).
6. **Once** (`sync.Once`) ensures a function is executed exactly once, even when called from multiple goroutines.
7. **Condition Variables** (`sync.Cond`) is an advanced primitive for waiting for or announcing state changes.
8. **Context** (`context.Context`) is not strictly a synchronization primitive, but used for cancellation signals and timeouts across goroutine boundaries.

Go encourages the use of **channels** (message passing) over traditional locks when possible. However, both approaches are available because different problems call for different tools.

## Choosing the Right Tool

Here's a quick decision guide:

| Scenario                            | Tool                  |
| ----------------------------------- | --------------------- |
| Passing data between goroutines     | **Channels**          |
| Simple counter or flag              | **Atomic operations** |
| Protecting a struct or complex data | **Mutex**             |
| Read-heavy cache or config          | **RWMutex**           |
| Waiting for goroutines to finish    | **WaitGroup**         |
| One-time initialization             | **Once**              |
| Cancellation or timeouts            | **Context**           |

## The Cost of Synchronization

Synchronization isn't free. It introduces overhead:

- **Performance**: Synchronized operations are slower than unsynchronized ones.
- **Contention**: Goroutines may wait for locks, reducing parallelism.
- **Complexity**: Code becomes harder to reason about and maintain.

The goal is to use **just enough** synchronization—protecting shared data without sacrificing too much performance.