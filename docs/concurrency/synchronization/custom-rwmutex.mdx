import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'

import customrwmutex from './code/customrwmutex/main.go?raw'

# Building a Reader-Priority RW Mutex

In the previous section we learned how to _use_ a readersâ€“writer mutex (`sync.RWMutex`). In this section, and for learning purposes, weâ€™ll implement a **minimal** read-preferred RW mutex. The implementation will be intentionally simple, with only four methods:

- `ReadLock`
- `ReadUnlock`
- `WriteLock`
- `WriteUnlock`

They mirror the behavior of Goâ€™s `sync.RWMutex`, but we give them our own names so itâ€™s obvious this is **our implementation**, not the standard libraryâ€™s.

## High-level idea

We want the following behavior:

- Multiple readers may hold the lock **at the same time**.
- While at least one reader is active, writers are locked out.
- Writers must have **exclusive access**, i.e. while a writer is active, both **readers** and **writers** are locked out.

This implementation is **read-preferred** because as long as there's an **active reader** and readers keep arriving, writers may starve.

## Mental model: the â€œroom with two entrancesâ€

Imagine a room that represents access to a shared resource:

- The room has two doors, one for **readers** and one for **writers**.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        â”‚
â”‚          ROOM          â”‚
â”‚    (shared resource)   â”‚
â”‚                        â”‚
â””â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”˜
      â–²           â–²
      â”‚           â”‚
    READERS     WRITERS
```

- **Multiple readers** may be inside simultaneously.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        â”‚
â”‚    Readers: ğŸ‘¤ ğŸ‘¤ ğŸ‘¤    â”‚
â”‚         (many)         â”‚
â”‚                        â”‚
â””â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”œâ”€â”€â”€â”˜
      â–²           â–²
      â”‚           â”‚
    READERS     WRITERS
```

- Only **one writer** may ever be inside, alone.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        â”‚
â”‚        Writer: âœï¸      â”‚
â”‚      (one, alone)      â”‚
â”‚                        â”‚
â””â”€â”€â”€â”¤â”€â”€â”€â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”œâ”€â”€â”€â”˜
      â–²           â–²
      â”‚           â”‚
    READERS     WRITERS
```

To manage this:

- We keep a **counter** of readers inside the room.
- The **first reader** locks the writersâ€™ door, and the **last reader** unlocks it.
- A writer simply tries the door â€” if it's locked (readers inside), they wait.
- Once a writer enters the room, it locks all doors.

<Admonition title="The Readers Counter">
  The **counter** is internal bookkeeping for readers to coordinate who
  locks/unlocks the writers' door.
</Admonition>

## Data Structures

Hereâ€™s the full structure backing our mutex:

```go
type ReadWriteMutex struct {
	readersCounter int        // number of active readers
	readersLock    sync.Mutex // protects readersCounter
	globalLock     sync.Mutex // blocks writers (and first reader)
}
```

- `readersCounter` tracks how many readers are currently in the room (a critical section of our code).
- `readersLock` ensures only one reader updates `readersCounter` at a time. Without it, two readers could both read the counter as `0`, both increment to `1`, and both try to lock `globalLock` (race condition).
- `globalLock` blocks access to all goroutines:
  - Readers use it to block writers: the first reader locks it, the last reader unlocks it.
  - Writers use it to block everybody else; when they're finished writing they unlock it.

## Locking logic: Readers

The `ReadLock` method controls how **readers** acquire locks:

```go
func (rw *ReadWriteMutex) ReadLock() {
	rw.readersLock.Lock()
	rw.readersCounter++
	if rw.readersCounter == 1 {
		rw.globalLock.Lock()
	}
	rw.readersLock.Unlock()
}
```

1. A reader acquires `readersLock` to safely update the counter.
2. It increments `readersCounter`, and if this reader is the number `1`, it locks `globalLock`, blocking writers (other readers can enter the room).
3. It releases `readersLock` (counter update is done) and proceeds to read.

Other readers can now enter concurrently without blocking each other.

## Locking logic: Writers

When a **writer** wants to write, the first thing it does is call the `WriteLock` method:

```go
func (rw *ReadWriteMutex) WriteLock() {
	rw.globalLock.Lock()
}
```

- If the `globalLock` is **unlocked**, the writer acquires it.
- If it's **locked** (by another writer or the first reader), the writer is blocked until lock is released.

<Admonition title="Acquiring Global Lock">
 The `globalLock` can be acquired:

- By a **writer** to exclude everybody else.
- By a **first reader** to exclude writers.

</Admonition>

## Unlocking logic: Readers

When a reader is done reading, it calls `ReadUnlock`:

```go
func (rw *ReadWriteMutex) ReadUnlock() {
	rw.readersLock.Lock()
	rw.readersCounter--
	if rw.readersCounter == 0 {
		rw.globalLock.Unlock()
	}
	rw.readersLock.Unlock()
}
```

1. Reader acquires `readersLock` to safely update the counter.
2. Decrements `readersCounter`.
3. If this reader is the **last one out** (`readersCounter == 0`), it unlocks `globalLock`, allowing a writer to proceed.
4. Releases `readersLock` (so other readers can update the counter)

## Unlocking logic: Writers

When a writer is done writing, it calls `WriteUnlock`:

```go
func (rw *ReadWriteMutex) WriteUnlock() {
	rw.globalLock.Unlock()
}
```

This releases `globalLock`, allowing the next waiting goroutine to proceed â€” whether it's another **writer** or the **first reader** in a group.

## Reader preference (writer starvation)

Our implementation is **read-preferring**, which means that if readers continuously arrive, **writers** may never acquire the lock. A writer can be starved indefinitely by a steady stream of readers. This happens because:

- New readers can enter as long as there is at least one active reader (they don't need `globalLock` to be **unlocked**, only the first reader does).
- The **writer** must wait for the `readersCounter` to drop to `0`, which never happens if readers keep coming.

This is **not a bug** â€” itâ€™s a design choice. More sophisticated implementations (including Goâ€™s `sync.RWMutex`) use additional coordination to avoid starvation. Weâ€™ll fix this later using **condition variables**.
