import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'
import mainGo from './code/for/infinite-goroutine/main.go?raw'
import loggerGo from './code/for/infinite-goroutine/logger/logger.go?raw'

# For Loops

Go has only one looping construct: the [for loop](https://go.dev/ref/spec#For_statements). However, it's flexible enough to handle all common looping scenarios.

## Basic for loop (three-component)

Go supports the classic C-style loop with initialization, condition, and post statements, all in one line, like this:

```go
package main

import "fmt"

func main() {
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }
    // Output: 0 1 2 3 4
}
```

Note that, after the `for` keyword, we don't use parentheses around the following statements (like other languages do). In this version of the loop, we use one statement and a couple of expressions after the `for` keyword:

- `i := 0` is used for initializing the variable used in the condition (runs once before the loop starts)
- `i < 5` is the condition (checked before each iteration)
- The `i++` is the **post statement** (runs after each iteration)

<Admonition type="warning" title="Variables in for loop">
  The variable `i` is declared in the initialization statement of the for loop.
  Its scope is limited to the loop itself; it cannot be accessed outside the
  loop.
</Admonition>

This loop can be written in a more idiomatic way using a `range` statement, which we'll cover later. But for now:

```go
package main
import "fmt"

func main() {
    for i := range 5 {
        fmt.Println(i)
    }
    // Output: 0 1 2 3 4
}
```

## While-style loop

Go doesn't have a `while` keyword. Just use for with only a condition:

```go
package main

import "fmt"

func main() {
    count := 0

    for count < 5 {
        fmt.Println(count)
        count++
    }
    // Output: 0 1 2 3 4
}
```

This loops keeps iterating until count is less than `5`; once `count` reaches `5`, the condition becomes `false` and the loop stops. That loop behaves like a traditional `while` loop found in other languages. For exmaple, in **Python** you would write:

```python
count = 0

while count < 5:
    print(count)
    count += 1
```

## Infinite loop - Use in Goroutines

If we omit any statements between the `for` keyword and the opening curly brace (`{`), we get an **infinite loop**:

```go
package main

import "fmt"

func main() {
    count := 0

    for {
        fmt.Println(count)
        count++

        if count >= 5 {
            break  // exit the loop
        }
    }
    // Output: 0 1 2 3 4
}
```

This loop will run forever unless we explicitly break out of it using the `break` statement. Infinite loops are useful for servers or long-running processes that need to keep running until stopped. Also for loops that need to run based on user input, for example:

<Code code={mainGo} lang="go" filename="infinite-goroutine/main.go" />

This is one of the common use cases for infinite loops: continuously listening for messages on a channel and processing them as they arrive.

<Code
  code={loggerGo}
  lang="go"
  filename="infinite-goroutine/logger/logger.go"
/>

We use an infinite loop here to keep the goroutine running, waiting for messages to log.

## Range loop

The [range clause](https://go.dev/wiki/Range) provides a way to iterate over an array, slice, string, map, or channel:

### Iterating over slices/arrays

Let's iterate over a slice:

```go
package main

import "fmt"

func main() {
    numbers := []int{10, 20, 30, 40, 50}

    // With index and value
    for i, num := range numbers {
        fmt.Printf("Index %d: %d\n", i, num)
    }

    // Only value (ignore index with _)
    for _, num := range numbers {
        fmt.Println(num)
    }

    // Only index
    for i := range numbers {
        fmt.Println("Index:", i)
    }
}
```

### Ranges Create Copies

When ranging over arrays or slices, Go creates a copy of each element. Modifying the loop variable does not affect the original collection:

```go
type Person struct {
    Name string
    Age  int
}

people := []Person{
    {Name: "Alice", Age: 25},
    {Name: "Bob", Age: 30},
}

// This won't modify the original slice
for _, person := range people {
    person.Age++  // modifying a copy
}

// Use index to modify original
for i := range people {
    people[i].Age++  // modifying the original
}
```

### Iterating over strings

When ranging over a string, you get runes (Unicode code points), not bytes:

```go
package main

import "fmt"

func main() {
    str := "Hello"

    for i, char := range str {
        fmt.Printf("Index %d: %c (rune: %d)\n", i, char, char)
    }
    // Output:
    // Index 0: H (rune: 72)
    // Index 1: e (rune: 101)
    // Index 2: l (rune: 108)
    // Index 3: l (rune: 108)
    // Index 4: o (rune: 111)
}
```

### Iterating over maps

When ranging over a map, you get key-value pairs:

```go
package main

import "fmt"

func main() {
    ages := map[string]int{
        "Alice": 25,
        "Bob":   30,
        "Carol": 35,
    }

    // Both key and value
    for name, age := range ages {
        fmt.Printf("%s is %d years old\n", name, age)
    }

    // Only keys
    for name := range ages {
        fmt.Println(name)
    }
}
```

Map iteration order is not guaranteed and will vary between runs.

## Break statement

The [break statement](https://go.dev/ref/spec#Break_statements) exits the loop immediately:

```go
package main

import "fmt"

func main() {
    for i := 0; i < 10; i++ {
        if i == 5 {
            break  // exit loop when i equals 5
        }
        fmt.Println(i)
    }
    // Output: 0 1 2 3 4
}
```

## Continue statement

The [continue statement](https://go.dev/ref/spec#Continue_statements) skips the current iteration and moves to the next one:

```go
package main

import "fmt"

func main() {
    for i := 0; i < 5; i++ {
        if i == 2 {
            continue  // skip when i equals 2
        }
        fmt.Println(i)
    }
    // Output: 0 1 3 4
}
```

When `i` is `2`, the `continue` statement skips the rest of the loop body and proceeds to the next iteration.

## Nested loops

You can nest loops inside each other, which is useful for working with multi-dimensional data structures:

```go
package main

import "fmt"

func main() {
    // Create a 3x4 matrix (3 rows, 4 columns)
    matrix := [][]int{
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
    }

    // Print the matrix
    fmt.Println("Matrix:")
    for row := 0; row < len(matrix); row++ {
        for col := 0; col < len(matrix[row]); col++ {
            fmt.Printf("%3d ", matrix[row][col])
        }
        fmt.Println()  // new line after each row
    }
}

// Output:
// Matrix:
//   1   2   3   4
//   5   6   7   8
//   9  10  11  12
```

Nothing wrong with the example above, but we can use `range` to make it more idiomatic:

```go
package main

import "fmt"

func main() {
    matrix := [][]int{
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
    }

    for i, row := range matrix {
        for j, value := range row {
            fmt.Printf("%3d ", value)
        }
        fmt.Println()
    }
}
```

And if you don't need the indexes, you can ignore them with `_`:

```go
for _, row := range matrix {
    for _, value := range row {
        fmt.Printf("%3d ", value)
    }
    fmt.Println()
}
```

### Breaking out of nested loops with labels

We can use a [label statement](https://go.dev/ref/spec#Label) to break out of outer loops:

```go
package main

import "fmt"

func main() {
outer:
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            fmt.Printf("i=%d, j=%d\n", i, j)
            if i == 1 && j == 1 {
                break outer  // breaks out of both loops
            }
        }
    }
    fmt.Println("Done")
}
```

In this example, when `i` is `1` and `j` is `1`, the `break outer` statement exits both loops immediately. Without the label, `break` would only exit the inner loop, but with the label, we can specify which loop to break out of.

## Goroutines with for loops

When using for loops with goroutines, be cautious about variable capture. Use local copies to avoid unexpected behavior:

```go
// WRONG - all goroutines will use the final value of i
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i)  // might print 5 five times
    }()
}

// CORRECT - pass i as parameter
for i := 0; i < 5; i++ {
    go func(num int) {
        fmt.Println(num)  // prints 0, 1, 2, 3, 4
    }(i)
}
```
