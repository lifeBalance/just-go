import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'

# For Loops

Go has only one looping construct: the [for loop](https://go.dev/ref/spec#For_statements). However, it's flexible enough to handle all common looping scenarios.

## Basic for loop (three-component)

The classic C-style loop with initialization, condition, and post statement:

```go
package main

import "fmt"

func main() {
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }
    // Output: 0 1 2 3 4
}
```

Components:

- `i := 0` is used for initializing the variable used in the condition (runs once before the loop starts)
- `i < 5` is the condition (checked before each iteration)
- The `i++` is the **post statement** (runs after each iteration)

<Admonition type="warning" title="Variables in for loop">
  The variable `i` is declared in the initialization statement of the for loop.
  Its scope is limited to the loop itself; it cannot be accessed outside the
  loop.
</Admonition>

## While-style loop

Go doesn't have a `while` keyword. Just use for with only a condition:

```go
package main

import "fmt"

func main() {
    count := 0

    for count < 5 {
        fmt.Println(count)
        count++
    }
    // Output: 0 1 2 3 4
}
```

This loops keeps iterating until count is less than `5`; once `count` reaches `5`, the condition becomes `false` and the loop stops.

## Infinite loop

Omit the condition entirely for an infinite loop:

```go
package main

import "fmt"

func main() {
    count := 0

    for {
        fmt.Println(count)
        count++

        if count >= 5 {
            break  // exit the loop
        }
    }
    // Output: 0 1 2 3 4
}
```

This loop will run forever unless we explicitly break out of it using the `break` statement. Infinite loops are useful for servers or long-running processes that need to keep running until stopped. Also for loops that need to run based on user input.

## Range loop

The [range clause](https://go.dev/wiki/Range) provides a way to iterate over an array, slice, string, map, or channel:

### Iterating over slices/arrays

Let's iterate over a slice:

```go
package main

import "fmt"

func main() {
    numbers := []int{10, 20, 30, 40, 50}

    // With index and value
    for i, num := range numbers {
        fmt.Printf("Index %d: %d\n", i, num)
    }

    // Only value (ignore index with _)
    for _, num := range numbers {
        fmt.Println(num)
    }

    // Only index
    for i := range numbers {
        fmt.Println("Index:", i)
    }
}
```

### Ranges Create Copies

When ranging over arrays or slices, Go creates a copy of each element. Modifying the loop variable does not affect the original collection:

```go
type Person struct {
    Name string
    Age  int
}

people := []Person{
    {Name: "Alice", Age: 25},
    {Name: "Bob", Age: 30},
}

// This won't modify the original slice
for _, person := range people {
    person.Age++  // modifying a copy
}

// Use index to modify original
for i := range people {
    people[i].Age++  // modifying the original
}
```

### Iterating over strings

When ranging over a string, you get runes (Unicode code points), not bytes:

```go
package main

import "fmt"

func main() {
    str := "Hello"

    for i, char := range str {
        fmt.Printf("Index %d: %c (rune: %d)\n", i, char, char)
    }
    // Output:
    // Index 0: H (rune: 72)
    // Index 1: e (rune: 101)
    // Index 2: l (rune: 108)
    // Index 3: l (rune: 108)
    // Index 4: o (rune: 111)
}
```

### Iterating over maps

When ranging over a map, you get key-value pairs:

```go
package main

import "fmt"

func main() {
    ages := map[string]int{
        "Alice": 25,
        "Bob":   30,
        "Carol": 35,
    }

    // Both key and value
    for name, age := range ages {
        fmt.Printf("%s is %d years old\n", name, age)
    }

    // Only keys
    for name := range ages {
        fmt.Println(name)
    }
}
```

Map iteration order is not guaranteed and will vary between runs.

## Break statement

The [break statement](https://go.dev/ref/spec#Break_statements) exits the loop immediately:

```go
package main

import "fmt"

func main() {
    for i := 0; i < 10; i++ {
        if i == 5 {
            break  // exit loop when i equals 5
        }
        fmt.Println(i)
    }
    // Output: 0 1 2 3 4
}
```

## Continue statement

The [continue statement](https://go.dev/ref/spec#Continue_statements) skips the current iteration and moves to the next one:

```go
package main

import "fmt"

func main() {
    for i := 0; i < 5; i++ {
        if i == 2 {
            continue  // skip when i equals 2
        }
        fmt.Println(i)
    }
    // Output: 0 1 3 4
}
```

When `i` is `2`, the `continue` statement skips the rest of the loop body and proceeds to the next iteration.

## Nested loops

You can nest loops inside each other:

```go
package main

import "fmt"

func main() {
    // Create a 3x4 matrix (3 rows, 4 columns)
    matrix := [][]int{
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
    }
    
    // Print the matrix
    fmt.Println("Matrix:")
    for row := 0; row < len(matrix); row++ {
        for col := 0; col < len(matrix[row]); col++ {
            fmt.Printf("%3d ", matrix[row][col])
        }
        fmt.Println()  // new line after each row
    }
}

// Output:
// Matrix:
//   1   2   3   4 
//   5   6   7   8 
//   9  10  11  12
```

### Breaking out of nested loops with labels

We can use a [label statement](https://go.dev/ref/spec#Label) to break out of outer loops:

```go
package main

import "fmt"

func main() {
outer:
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            fmt.Printf("i=%d, j=%d\n", i, j)
            if i == 1 && j == 1 {
                break outer  // breaks out of both loops
            }
        }
    }
    fmt.Println("Done")
}
```

## Goroutines with for loops

When using for loops with goroutines, be cautious about variable capture. Use local copies to avoid unexpected behavior:

```go
// WRONG - all goroutines will use the final value of i
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i)  // might print 5 five times
    }()
}

// CORRECT - pass i as parameter
for i := 0; i < 5; i++ {
    go func(num int) {
        fmt.Println(num)  // prints 0, 1, 2, 3, 4
    }(i)
}
```