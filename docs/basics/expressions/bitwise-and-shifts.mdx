import Admonition from '@components/Admonition.astro'

# Bitwise and shifts

[Bitwise operators](https://go.dev/ref/spec#Integer_operators) and [shift operators](https://go.dev/ref/spec#Shift_operators) operate on integer types. The following table contains a summary of operators:

| Operator | Meaning      | Example                         |
| -------- | ------------ | ------------------------------- |
| `&`      | bitwise AND  | `0b1100 & 0b1010 = 0b1000`      |
| `|`      | bitwise OR   | `0b1100 | 0b1010 = 0b1110`      |
| `^`      | bitwise XOR  | `0b1100 ^ 0b1010 = 0b0110`      |
| `&^`     | bit clear    | `0b1100 &^ 0b0101 = 0b1000`     |
| `<<`     | left shift   | `0b00001100 << 2 = 0b00110000`  |
| `>>`     | right shift  | `0b00001100 >> 2 = 0b00000011`  |

Note: shift counts are unsigned; the result type is the left operand. Prefer unsigned integers for shifting to avoid sign-related surprises.


```go
var x uint8 = 0b1100
var y uint8 = 0b1010

fmt.Printf("%04b\n", x & y)   // 1000 (AND)
fmt.Printf("%04b\n", x | y)   // 1110 (OR)
fmt.Printf("%04b\n", x ^ y)   // 0110 (XOR)

mask := uint8(0b0101)
fmt.Printf("%04b\n", x &^ mask) // 1000 (clear bits in mask)

fmt.Printf("%08b\n", x << 1)  // 00011000
fmt.Printf("%08b\n", x >> 2)  // 00000011
```

Shifts are by unsigned counts. The result type is the left operand’s type. Be mindful of sign when shifting signed integers; unsigned types make intent clearer.

<Admonition variant="tip" title="Bit clear (&^)">
`a &^ b` clears any bits in `a` that are set in `b`. It’s handy for unsetting flags.
</Admonition>
