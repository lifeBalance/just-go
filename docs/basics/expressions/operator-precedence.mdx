import Admonition from '@components/Admonition.astro'

# Operator precedence

When you mix [operators](https://go.dev/ref/spec#Operators) of different kind, there are some precedence rules to determine what operations run first. From higher to lower precedence:

1. Parentheses â€” add them when in doubt.
2. Unary operators â€” `+x`, `-x`, `!x`, `^x`, `*p`, `&x` (apply before binary ops)
3. Multiplicative:
   - `*`, `/`, `%` (multiplication, division, remainder)
   - `<<`, `>>` (bitwise shifts)
   - `&`, `&^` (bitwise AND, AND NOT)
4. Additive:
   - `+`, `-` (addition, subtraction)
   - `|`, `^` (bitwise OR, XOR)
5. Comparison â€” `==`, `!=`, `<`, `<=`, `>`, `>=`
6. Logical AND â€” `&&`
7. Logical OR â€” `||`

<Admonition variant="tip" title="Evaluation order">
Within each precedence level, operators associate leftâ€‘toâ€‘right. Parentheses always take precedence, and unary operators apply before binary operators.
</Admonition>

Mixing **arithmetic** and **bitwise** operators is common in systems work, parsing, compression, graphics, hashing/cryptography, and performanceâ€‘critical code. Itâ€™s much less common in everyday business logic.

## Bitwise Shifts are like Multiplication/Division

Shifts scale by powers of two. They are equivalent to multiplication and division by powers of two, so they share the same precedence group as `*`, `/`, and `%`.

### Left shifts

A left shift (`<<`) multiplies by a power of two, check this formula:

```
a << n == a * 2^n
```

Example:

```
3 << 2 == 12  // 3 * 2^2
```

### Right shifts

A right shift (`>>`) divides by a power of two, check this formula:

```
a >> n == floor(a / 2^n)
```

Note: right shift is arithmetic for signed integers (sign bit propagates) and logical for unsigned (zeros shift in). Prefer unsigned if you need zeroâ€‘fill behavior.

Examples:
- `a << 2` is `a * 4`
- `c >> 1` is `c / 2`

Similarly, bitwise AND appears in the same group as multiplication, while bitwise OR and XOR share the group with addition because their precedence mirrors those arithmetic operations.

## Bitwise AND and AND NOT is like Multiplication/Remainder

Bitwise AND (`&`) groups with the multiplicative operators; bitwise OR (`|`) and XOR (`^`) group with the additive operators. This matters when you mix bitwise and arithmetic without parentheses.

Formulas:
```
// Per bit (bits in {0,1}):
x & y == x * y

// Useful identities:
a | b == (a ^ b) + (a & b)
a + b == (a ^ b) + 2*(a & b)
```

## Bitwise OR and XOR is like Addition/Subtraction

Bitwise OR (`|`) and XOR (`^`) share the additive group with `+` and `-`. They associate leftâ€‘toâ€‘right, so mixed expressions without parentheses parse the same way.

### Bitwise OR

The `|` operator sets a bit when either input bit is 1.

```go
m := 2 | 4  // 6
```

If you visualize binary integers, itâ€™s clearer:

```go
x := uint8(0b0010)          // 0 0 1 0 ðŸ‘‰ 2
y := uint8(0b0100)          // 0 1 0 0 ðŸ‘‰ 4
fmt.Printf("%04b\n", x|y)   // 0 1 1 0 ðŸ‘‰ 6
```

### Bitwise XOR

The `^` operator sets a bit when input bits differ.

```go
n := 8 ^ 3  // 11
```

Let's visualize with binary integers:

```go
p := uint8(0b1000)          // 1 0 0 0 ðŸ‘‰ 8
q := uint8(0b0011)          // 0 0 1 1 ðŸ‘‰ 3
fmt.Printf("%04b\n", p^q)   // 1 0 1 1 ðŸ‘‰ 11 
```
