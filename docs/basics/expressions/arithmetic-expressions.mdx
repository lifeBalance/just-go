import Admonition from '@components/Admonition.astro'

# Arithmetic expressions

[Arithmetic expressions](https://go.dev/ref/spec#Arithmetic_expressions) perform calculations on numeric operands. Golang supports both integer and floating-point arithmetic. The following table contains the basic arithmetic operators:

| Operator | Meaning        | Example     |
| -------- | -------------- | ----------- |
| `+`      | addition       | `2 + 2 = 4` |
| `-`      | subtraction    | `3 - 2 = 1` |
| `*`      | multiplication | `2 * 2 = 4` |
| `/`      | division       | `4 / 2 = 2` |
| `%`      | remainder      | `5 % 2 = 1` |

There's no **exponentiation operator**; use `math.Pow` for that.

## Operator Precedence

[Operator precedence](https://go.dev/ref/spec#Operator_precedence) determines the order in which operations are performed. In Go, the operator precedence follows the PEMDAS rule:

1. **P**arentheses
2. **E**xponents (via `math.Pow`, not an operator)
3. **M**ultiplication, Division, Remainder
4. **A**ddition, **S**ubtraction

For example:

```go
result := 2 + 3 * 4    // 14 (not 20)
```

In the example above, multiplication happens first, so `3 * 4 = 12`, then addition is performed `2 + 12 = 14`. To change the order of operations, use parentheses:

```go
result := (2 + 3) * 4  // 20
// Parentheses first: 2 + 3 = 5, then 5 * 4 = 20
```

## Integer division

When both operands of the division operator `/` are integers, Go performs **integer division**, which discards any fractional part and returns an integer result. For example:

```go
fmt.Println(7/2)    // 3
fmt.Println(8/3)    // 2
```

As you can see, the fractional part is discarded, and the result truncates toward zero. For example:

```go
fmt.Println(7 / 2)    // 3 and not 3.5 or 4
```

Mixed signs truncate the quotient toward zero as well.

```go
fmt.Println(-7 / 2)   // -3
fmt.Println(7 / -2)   // -3
fmt.Println(-7 / -2)  // 3
```

To get a **fractional result**, use **floating‑point operands** (convert explicitly if needed):

```go
fmt.Println(7.0/2)           // 3.5
fmt.Println(float64(7) / 2)    // 3.5
```

<Admonition type="info" title="Division by zero">
  In Go, dividing an integer by zero using the `/` operator results in a
  **compile-time error**. For floating-point division, dividing by zero yields
  positive or negative infinity, or NaN (Not a Number), depending on the
  operands.
</Admonition>

## The Remainder Operator

The remainder operator `%` works as in other programming languages:

```go
fmt.Println(7 % 3)    // 1
```

In case you're not familiar, the remainder operator returns the remainder after **integer division**. So `7` divided by `3` is `2` with a remainder of `1`.

The remainder has the same sign as the **dividend**, for example:

```go
fmt.Println(-7 % 3)    // -1 (dividend is -7)
fmt.Println(7 % -3)    // 1
fmt.Println(-7 % -3)   // -1
```

### Cycling through a range

The remainder operator is often used to cycle through a range of values. For example, let's say you have an array of values, and you want to cycle throught them:

```go
months := []string{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

for i := 0; i < 15; i++ {
    month := months[i % len(months)]
    fmt.Println(month)
}
```

This will print the months, cycling back to `Jan` after `Dec`. The reason is that `len(months)` is `12`, so when `i` reaches `12`, `i % 12` becomes `0`, and the cycle starts over.

## Unary Operators are Statements

[Increment and decrement](https://go.dev/ref/spec#IncDec_statements) are actually **statements** (not expressions). For example:

```go
i := 0

i++
fmt.Println(i) // 1

i--
fmt.Println(i) // 0
```

They cannot appear inside larger expressions:

```go
fmt.Println(i++) // ❌ compile error: ++ used as value

x := x++ // ❌ compile error: ++ used as value

x = x--  // ❌ compile error: -- used as value
```

Use them on **integer variables** only:

```go
f := 3.14
f++ // ❌ compile error: ++ operator not defined for float64
```

<Admonition type="warning" title="No prefix forms">
  In Go, there are no prefix versions of the increment (`++`) and decrement
  (`--`) operators. They can only be used as postfix operators. So using `++i`
  or `--i` would generate a **compile error**.
</Admonition>

## Compound assignment

Shorthand operators update a variable in place; `x += y` is the same as `x = x + y` (left side evaluated once).

| Operator | Meaning              | Example   |
| -------- | -------------------- | --------- |
| `+=`     | add and assign       | `n += 3`  |
| `-=`     | subtract and assign  | `n -= 1`  |
| `*=`     | multiply and assign  | `n *= 2`  |
| `/=`     | divide and assign    | `n /= 2`  |
| `%=`     | remainder and assign | `n %= 10` |
