import Admonition from '@components/Admonition.astro'

# Logical expressions

[Logical expressions](https://go.dev/ref/spec#Logical_operators) are used to perform [boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra) by operating on expressions that evaluate to boolean values (`true` and `false`). Go offers the same operators we can find in many other languages:

- `&&` is logical AND.
- `||` is logical OR.
- `!` negates a boolean value.

<Admonition variant="warning" title="Boolean values">
  They only work with boolean values (`true` and `false`).
</Admonition>

## AND operator `&&`

As a remainder, here is the truth table for the `&&` operator:

| `a`   | `b`   | `a && b` |
| ----- | ----- | -------- |
| false | false | false    |
| false | true  | false    |
| true  | false | false    |
| true  | true  | true     |

## OR operator `||`

And the truth table for the `||` operator:

| `a`   | `b`   | `a \|\| b` |
| ----- | ----- | ---------- |
| false | false | false      |
| false | true  | true       |
| true  | false | true       |
| true  | true  | true       |

## NOT operator `!`

The `!` operator negates a boolean value. Here is its truth table:

| `a`   | `!a`  | 
| ----- | ----- |
| false | true  |
| true  | false |

In other words, it flips `true` to `false` and `false` to `true`.

## Precedence

When combining logical expressions with other kinds of expressions, remember that `&&` has higher precedence than `||`. For example:

```go
age := 25
income := 50000

eligible := age > 18 || income > 40000 && age < 65
```

In the example above, a person is considered `eligible` if:

- They are older than 18.
- Or if they have an income greater than 40,000 **and** are younger than 65.

Using parentheses can help clarify the intended logic:

```go
eligible := age > 18 || (income > 40000 && age < 65)
```

The `&&` operator is evaluated first due to its higher precedence.

## Short‑circuit evaluation

As with other operators, the order of evaluation in boolean expressions is **left to right**. This is particularly important for `&&` and `||` because it enables short‑circuit evaluation.

<Admonition type="info" title="Short‑circuit evaluation">
  Short‑circuit evaluation means that in a logical expression, evaluation stops
  as soon as the overall truth value is determined. This can prevent unnecessary
  computations and side effects.
</Admonition>

Short‑circuit evaluation enables **safe guard** patterns:

```go
if s != nil && len(s) > 0 {
  fmt.Println("first:", s[0])
}
```

The code above is safe because if `s` is `nil`, the second condition (`len(s) > 0`) is never evaluated, preventing a potential panic. Another pattern for short‑circuiting is **caching**:

```go
// Early success: right side won’t run if left is true
if cached || compute() {
  // ...
}
```

The `compute()` function is only called if `cached` is `false`, which can save time and resources.
