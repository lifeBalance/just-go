import Admonition from '@components/Admonition.astro'

# Boolean (logical) expressions

[Boolean (logical) expressions](https://go.dev/ref/spec#Logical_operators) use the following operators to combine or negate boolean values:

- `&&` is logical AND. It evaluates the left operand first; if it’s false, the right side is not evaluated (short‑circuit).
- `||` is logical OR. If the left is true, the right side is not evaluated.
- `!` negates a boolean value.

Operator quick reference:

Operator | Meaning      | Example          
-------- | ------------ | -----------------
`&&`     | logical AND  | `true && false`  
`\|\|`     | logical OR   | false \|\| true  
`!`      | logical NOT  | `!false`         



## Short‑circuit evaluation

Short‑circuiting enables safe “guard” patterns:

```go
// Safe: second test only runs when needed
if s != nil && len(s) > 0 {
  fmt.Println("first:", s[0])
}

// Early success: right side won’t run if left is true
if cached || compute() {
  // ...
}
```

Two quick demonstrations of short‑circuiting in action:

```go
// If the left side is false, the right side is never evaluated
if false && riskyFunction() {
    // riskyFunction() is never called
}

// If the left side is true, the right side is never evaluated
if true || riskyFunction() {
    // riskyFunction() is never called
}
```

And another common guard to avoid panics with indexing:

```go
if len(slice) > 0 && slice[0] == 42 {
    fmt.Println("First element is 42")
}
```

You can build readable expressions by naming intermediate results:

```go
isAdult := age >= 18
hasIncome := income > 30_000
eligible := isAdult && (hasIncome || hasGoodCredit)
```

<Admonition variant="tip" title="Evaluation order">
Operands are evaluated left‑to‑right. With `&&` and `||`, the right operand may not be evaluated at all. This is often used to avoid panics when accessing slices or maps.
</Admonition>
