import Admonition from '@components/Admonition.astro'

# Logical expressions

[Logical expressions](https://go.dev/ref/spec#Logical_operators) are used to perform [boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra) by operating on expressions that evaluate to boolean values (`true` and `false`). Go offers the same operators we can find in many other languages:

- `&&` is logical AND.
- `||` is logical OR.
- `!` negates a boolean value.

<Admonition variant="warning" title="Boolean values">
They only work with boolean values (`true` and `false`).
</Admonition>

## AND operator `&&`

As a remainder, here is the truth table for the `&&` operator:

| A      | B      | A && B |
| ------ | ------ | ------ |
| false  | false  | false  |
| false  | true   | false  |
| true   | false  | false  |
| true   | true   | true   |

## OR operator `||`

And the truth table for the `||` operator:

| A      | B      | A \|\| B |
| ------ | ------ | -------- |
| false  | false  | false    |
| false  | true   | true     |
| true   | false  | true     |
| true   | true   | true     |
s
## NOT operator `!`

The `!` operator negates a boolean value. Here is its truth table:

| A      | !A     |
| ------ | ------ |
| false  | true   |
| true   | false  |

## Precedence

When combining logical expressions with other kinds of expressions, remember that `&&` has higher precedence than `||`. For example:

```go
age := 25
income := 50000

eligible := age > 18 || income > 40000 && age < 65
```

In the example above, a person is considered `eligible` if:

- They are older than 18.
- Or if they have an income greater than 40,000 **and** are younger than 65.

Using parentheses can help clarify the intended logic:

```go
eligible := age > 18 || (income > 40000 && age < 65)
```

The `&&` operator is evaluated first due to its higher precedence.

## Short‑circuit evaluation

The order of evaluation is **left to right**, which is important for `&&` and `||` because of short‑circuiting. Short‑circuiting enables safe “guard” patterns:

```go
// Safe: second test only runs when needed
if s != nil && len(s) > 0 {
  fmt.Println("first:", s[0])
}
```

The code above is safe because if `s` is `nil`, the second condition (`len(s) > 0`) is never evaluated, preventing a potential panic. Another pattern for short‑circuiting is **caching**:

```go
// Early success: right side won’t run if left is true
if cached || compute() {
  // ...
}
```

The `compute()` function is only called if `cached` is `false`, which can save time and resources.

