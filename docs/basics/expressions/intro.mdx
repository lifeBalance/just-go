import Admonition from '@components/Admonition.astro'

# Expressions

An [expression](https://go.dev/ref/spec#Expressions) is any piece of code that produces a value  by applying operators and functions to operands. In the next section we'll dive deeper into **operands** and **primary expressions**, but for now, let's explore the different types of **operators** you can find in Go:

- [Arithmetic operators](https://go.dev/ref/spec#Arithmetic_operators) for performing mathematical calculations.
- [Comparison operators](https://go.dev/ref/spec#Comparison_operators) for comparing values.
- [Logical operators](https://go.dev/ref/spec#Logical_operators) for combining boolean expressions.
- [Integer operators](https://go.dev/ref/spec#Integer_operators) for bitwise manipulation and shifts.

Also, depending on the amount of operands they work with, **operators** can be classified as:

- **Unary operators**: work with a single operand (e.g., `-x`, `!flag`, `^mask`).
- **Binary operators**: work with two operands (e.g., `a + b`, `x < y`, `p && q`).

Weâ€™ll look at each family in the next sections.

## Expressions vs statements

It's important to distinguish between [expressions](https://go.dev/ref/spec#Expressions) and [statements](https://go.dev/ref/spec#Statements). Expressions produce values:

```go
5 + 3           // expression, evaluates to 8
x > 10          // expression, evaluates to true or false
getUserName()   // expression if it returns a value
```

Statements perform actions but don't produce values:

```go
x := 5          // assignment statement
if x > 10 {}    // if statement
for i := 0; i < 10; i++ {}  // for statement
```

However, some things can be used as both:

```go
// Function call as a statement (ignoring return value)
fmt.Println("hello")

// Function call as an expression (using return value)
length := len("hello")
```

### Expression complexity

You can combine expressions to create complex logic:

```go
age := 25
income := 50000
hasGoodCredit := true

// Complex boolean expression
canGetLoan := (age >= 18 && age <= 65) &&
              (income > 30000 || hasGoodCredit) &&
              !hasBankruptcy

// Breaking it down improves readability
isValidAge := age >= 18 && age <= 65
hasFinancialStability := income > 30000 || hasGoodCredit
canGetLoan := isValidAge && hasFinancialStability && !hasBankruptcy
```

<Admonition type="tip" title="Best practice">
While Go allows complex expressions, breaking them into smaller, named parts often makes code more readable and easier to debug.
</Admonition>
