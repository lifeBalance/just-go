import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'

import demoCmdCode from './code/demo/cmd/greet/main.go?raw'
import demoPkgCode from './code/demo/foo/foo.go?raw'

# Documentation

The Go project [takes documentation seriously](https://go.dev/blog/godoc). Every Go installation includes the [godoc](https://go.dev/cmd/godoc/) documentation tool that automatically parses your [Go comments](https://go.dev/doc/comment) to extract documentation.

## Go Comments

[Go comments](https://go.dev/doc/comment) can be used at different levels of a project, to explain:

- Packages
- Commands
- Types
- Functions
- Constants
- Variables

Those comments live next to your source, but they can also be used to automatically generate proper **documentation** by using the [godoc](https://go.dev/cmd/godoc/) documentation tool .

## A Demo Project

Let's create a demo project to demonstrate how comments and docs work together. Create a `demo` folder, change into it, and initialize a module:

```
go mod init myapp.com/demo
```

> [!WARNING]
> Avoid using a bare name like `myapp` when you run `go mod init`. Always choose a **module path** that contains a dot—something like `example.com/myapp`. The `pkgsite` tooling (and other parts of the Go ecosystem) assume short, dot-free module names belong to the standard library, so your docs won’t render correctly if you omit it.

After adding some code, we end up with this:

```
demo/
├── go.mod
├── cmd/
│   └── greet/
│       └── main.go
└── foo/
    └── foo.go
```

The `foo` package looks like this:

<Code code={demoPkgCode} lang="go" title="foo/foo.go" />

As you can see it includes:

- A package comment describing what `foo` provides.
- A `Greeter` struct type with a field-level comment.
- A `DefaultMessage` constant used when callers omit custom text.
- Two exported functions (`New` and `Greet`) with documentation explaining their behavior.

Then we have the `cmd/greet/main.go` file:

<Code code={demoCmdCode} lang="go" title="cmd/greet/main.go" />

This command uses the `flag` package to accept both a `--name` and a `--message` flag, so you can try different combinations when running it:

```sh
cd demo
go run ./cmd/greet -name "Alice"
Hello, Alice! Welcome to the Foo greeting tool!
```

Or:

```sh
go run ./cmd/greet -name "Bob" -message "Welcome aboard"
Hello, Bob! Welcome aboard
```

## Accessing the Documentation in the Command Line

From inside `demo/`, we could access the documentation on the command line:

```sh
go doc ./foo
```

And we should get a summary of all exported identifiers, in the command-line:
```
package foo // import "demo/foo"

Package foo provides helpers for building friendly greetings.

const DefaultMessage = "Welcome to the Foo greeting tool!"
type Greeter struct{ ... }
    func New(message string) Greeter
```

We can drill down further:

```sh
go doc demo/foo         # package overview
go doc demo/foo.Greeter # type docs
go doc demo/foo.Greeter.Greet
```

## Accessing the Documentation in the Browser

To view the documentation in a browser, we have to install the [pkgsite](https://pkg.go.dev/golang.org/x/pkgsite) package:

```sh
go install golang.org/x/pkgsite/cmd/pkgsite@latest
```

> [!WARNING]
> There's used to be a package named [godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc), but it was deprecated several years ago.


Once the package has been installed, we can launch a local HTTP server on whatever port:
```sh
pkgsite -http=:8080
```

Then head to [http://localhost:8080/demo](http://localhost:8080/demo).

> [!NOTE]
> The `pkgsite` command renders the same UI as [pkg.go.dev](https://pkg.go.dev/), making it ideal for previewing docs before publishing code.
