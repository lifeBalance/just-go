import Admonition from '@components/Admonition.astro'

# Introduction

In the previous sections we saw how variables can be created in two ways:

- Using an explicit syntax.
- Using a shorthand syntax.

In this section we'll go a bit deeper, and introduce new features related to variables and constants.

## Explicit Sintax

Creating variables using the explicity syntax it's a two step process:

```go
var username string // Declaration
username = "Bob"    // Assignment
```

1. The **first step** is known as **variable declaration**. Here we use the `var` keyword to announce that we'll be creating a variable, then we write the **name of the variable**, then its **type**.

2. In the **second step** we assign a value to the variable. Note that the value we assign must match the **type** of the variable we specified in the declaration.

Note that this syntax also allows to perform the assignment at the same time:

```go
var username string =  "Bob" // Declaration and Assignment
```

It's also possible to **omit the type**, in which case the Go compiler will infer the type from the value being assigned:

```go
var username = "Bob" // Look Ma, no type!
```

And we can **declare** multiple variables at the same time:

```go
var name1, name2 string
```

### The Zero Value

When we declare a variable without assigning it a value, the variable is initialized with the **zero value** for its type:

- `0` for numbers.
- `''` for strings.
- `false` for booleans.
- `nil` for [interfaces][6] and reference types(slice, pointer, map, channel, function).

The **zero-value mechanism** ensures that a variable always holds a value according to its type.

<Admonition type="info" title="No Uninitialized Variables">
  In Go there is no such thing as an uninitialized variable.
</Admonition>

### Factoring variable Declarations

Sometimes we have to declare a bunch of variables, having to repeat the `var` keyword gets old very quickly. It‚Äôs much more clean if we factor the declarations under one `var` keyword:

```go
var (
    message string
    num int
    answer bool
    price float32
)
```

Also when we are declaring multiple variables that share the same type, we can group them in one line:

```go
var (
    message, question string // üëà
    num int
    answer bool
    price float32
)
```

## Shorthand Syntax

Go offers a [shorthand syntax](https://golang.org/ref/spec#Short_variable_declarations) that allows us to declare and assign values in a slightly shorter fashion:

```go
username := "Bob" // Declaration and Assignment
```

In this case we don't have to use the `var` keyword to announce that we're declaring a variable; the Go compiler is smart enough to infer the fact from the `:=` operator.
Also, the compiler is able to infer the **type** of the variable from the type of value we're using in the assignment.

<Admonition>
  The `:=` operator is known as the [short variable declaration
  operator](https://go.dev/ref/spec#Short_variable_declarations). In **Python**
  is known as the **walrus operator**, and it works a bit different.
</Admonition>

The shorthand syntax `:=` can only be used **inside functions**. If you try to use it at the package level, you'll get a compilation error.

```go
package main

username := "Bob" // ‚ùå Error

func main() {
    username := "Bob" // ‚úÖ Correct
}
```

<Admonition type="error" title="Syntax Error">
  Do not use the `:=` operator outside functions!
</Admonition>

Sometimes, when using the shorthand syntax, we may want to specify the type of the variable explicitly. We can do so using a **type casting expression**:

```go
pi := float32(3.14)
```

## Naming Conventions

We can name our variables whatever we want, respecting some basic rules:

- We can use any combination of letter, digits and the `_` character.
- We cannot use Go [keywords](https://go.dev/ref/spec#Keywords) or [predeclared identifiers](https://go.dev/ref/spec#Predeclared_identifiers).
- The **first character** in our identifier can not be a number.
- Names are **case-sensitive**.
- By convention, variable names in Go use **camelCase**.

## Multiple Assignment

Go allows us to assign several values at the same time:

```go
username1, username2 = "Bob", "Lisa"
```

<Admonition type="info" title="Tuple Assignments">
  These are known as tuple assignments.
</Admonition>

This also works when we create the variables:

```go
var name1, name2 string = "Bob", "Lisa"
```

It works with **shorthand syntax**:

```go
name1, name2 := "Bob", "Lisa"
```

And it also works with **constants**:

```go
const name1, name2 string = "Bob", "Lisa"
```

## The Blank Identifier

Sometimes we need to ignore some values, for example when a function returns multiple values but we are interested only in some of them. In these cases we can use the [blank identifier](https://golang.org/ref/spec#Blank_identifier) (`_`) to discard the values we don't care about:

```go
value, _ := someFunction() // We ignore the second return value
```
