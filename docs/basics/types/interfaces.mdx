import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'
import { Image, Picture } from 'astro:assets'

import typeAssertions1 from './code/interfaces/type-assertions/main.go?raw'
import typeAssertions2 from './code/interfaces/type-assertions2/main.go?raw'

# Interfaces

An [interface](https://go.dev/ref/spec#Interface_types) is a type that specifies a set of method signatures. For example:

```go
type Animal interface {
    Speak() string
}
```

`Animal` is an interface that implements a method named `Speak`, which returns a string. Any type that implements the methods defines by an interface, automatically satisfies the interface - no explicit declaration needed. Now, if we define a `Dog` type, and add a `Speak` method to it:

```go
type Dog struct{}

func (d Dog) Speak() string {
    return "Woof!"
}
```

<Admonition title="Implicit Implementation">
  Go uses **implicit implementation**, we don't need to explicitely declare that
  a type implements an interface. As long as the type implements the methods
  specified in the interface, it satisfies the interface.
</Admonition>

We can say that any `Dog` instance will satisfy the `Speak` interface. Let's now create a `Cat` type that also implements this interface:

```go
type Cat struct{}

func (c Cat) Speak() string {
    return "Meow!"
}
```

Ok, so any `Cat` instance will also satisfy the `Animal` interface. But how is that useful?

## Using Interfaces

We can write functions that accept the interface type, and they'll work with any type that implements it:

```go
// Both Dog and Cat implement Animal automatically
func MakeSound(a Animal) {
    fmt.Println(a.Speak())
}
```

This function accepts an `Animal` interface, so we can pass either a `Dog` or a `Cat`:

```go
dog := Dog{}
cat := Cat{}

MakeSound(dog)  // "Woof!"
MakeSound(cat)  // "Meow!"
```

Since we wrote `MakeSound` for the `Animal` interface, it can be used for any type that implement this interface. This is useful, because imagine we have 10 or 20 animal types; if all of them implement the `Animal` interface (in other words, implement the `Speak` method) we can add behaviour to **all of them** without having to define the method 20 times (once per animal). We just have to define it once, for the `Animal` interface, and they all will be able to use that new behaviour.

## Interface Values

We can create instances of interfaces:

```go
type Dog struct{}
func (d Dog) Speak() string {
    return "Woof!"
}

type Cat struct{}
func (c Cat) Speak() string {
    return "Meow!"
}

type Animal interface {
    Speak() string
}
func MakeSound(a Animal) {
    fmt.Println(a.Speak())
}


var animal Animal

animal = Dog{}
fmt.Println(animal.Speak())  // "Woof!"

animal = Cat{}
fmt.Println(animal.Speak())  // "Meow!"
```

In the example above, we defined `dog` and `cat` as instances of `Dog` and `Cat` respectively. But since both of them satisfy the `Animal` interface, we can assign the instances to a variable of type `Animal`.

<Admonition>
  The variable `animal` doesn't care about the concrete type (`Dog` or `Cat`).
  It only cares that the type has a `Speak()` method.
</Admonition>

This is super useful, because we can create collections of different types:

```go
animals := []Animal{
    Dog{},
    Cat{},
    Dog{},
}

for _, animal := range animals {
    fmt.Println(animal.Speak())
}
// Output:
// Woof!
// Meow!
// Woof!
```

Without interfaces, we couldn't put dogs and cats in the same slice.

## The Problem that Interfaces Solve

To really appreciate the value of interfaces, let's try to implement some methods without them:

```go
type Dog struct {
    Sound string
}

type Cat struct {
    Sound string
}

// Without interfaces, we need separate functions for each type
func MakeDogSound(d Dog) {
    fmt.Println(d.Sound)
}

func MakeCatSound(c Cat) {
    fmt.Println(c.Sound)
}

func main() {
    dog := Dog{Sound: "Woof!"}
    cat := Cat{Sound: "Meow!"}

    MakeDogSound(dog)  // "Woof!"
    MakeCatSound(cat)  // "Meow!"

    // We can't create a collection of mixed types
    // This won't compile:
    // animals := []??? {dog, cat}  // What type goes here?
}
```

Notice the problems:

1. **Code duplication**: We need `MakeDogSound` and `MakeCatSound` - two functions that do the exact same thing (print the `Sound` field)
2. **No collections**: We can't create a slice containing both dogs and cats
3. **Poor scalability**: If we add 10 more animal types, we need 10 more methods

Now imagine we want to add a new behavior, like making all animals sleep:

```go
// Without interfaces - need a function for each type
func MakeDogSleep(d Dog) {
    fmt.Println("Dog is sleeping: Zzz...")
}

func MakeCatSleep(c Cat) {
    fmt.Println("Cat is sleeping: Zzz...")
}

// Add 10 animals? Write 10 more functions!
```

With interfaces, we solve all these problems:

```go
type Animal interface {
    Speak() string
}

// One function works for ALL types that satisfy Animal
func MakeSound(a Animal) {
    fmt.Println(a.Speak())
}

func MakeSleep(a Animal) {
    fmt.Println("Sleeping: Zzz...")
}

func main() {
    dog := Dog{Sound: "Woof!"}
    cat := Cat{Sound: "Meow!"}

    // Collections of mixed types work perfectly
    animals := []Animal{dog, cat, dog}

    for _, animal := range animals {
        MakeSound(animal)
        MakeSleep(animal)
    }

    // Add 100 new animal types? No new functions needed!
}
```

**The key insight**: Interfaces let us write code that works with behaviors (methods) rather than concrete types. This makes our code more flexible, reusable, and easier to extend.

## Type Assertions

A [type assertion](https://go.dev/tour/methods/15) is an [expression](https://go.dev/ref/spec#Type_assertions) that we can use on interfaces to extract a value, only if it's of a certain type. For example:

<Code code={typeAssertions1} lang="go" />

Since the interface `x` has a **dynamic type**, we could assign a value of any type to it. Using a **type assertion**, we make sure it contains an integer value before trying to assign it to `anInteger`.

<Admonition>
In the code above, if `x` is not an `int`, `ok` will be `false`.
</Admonition>

Check this other example:

<Code code={typeAssertions2} lang="go" />

In the code above, `someDude` could be anything, so before extracting the values of any of its fields, we have to make sure that the types match the recipients.

<Admonition title='any is an alias for interface{}'>
In the code above, we're using `any`, which is equivalent to `interface{}`.
</Admonition>