import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'
import { Image, Picture } from 'astro:assets'
import sliceCode from './code/slices/main.go?raw'
import sliceCode2 from './code/slices2/main.go?raw'
import sliceCode3 from './code/slices3/main.go?raw'
import sliceCode4 from './code/slices4/main.go?raw'
import sliceCode5 from './code/slices5/main.go?raw'
import sliceCode6 from './code/slices6/main.go?raw'
import sliceCode7 from './code/slices7/main.go?raw'
import sliceCode8 from './code/slices8/main.go?raw'
import sliceCode9 from './code/slices9/main.go?raw'
import sliceCode10 from './code/slices10/main.go?raw'
import sliceHeader from './images/slice_header.png'
import slicingSlices from './images/slicing_slices.png'
import sliceDescriptor2 from './images/slice_descriptor_2.png'

# Slices

In the previous section we saw how **arrays** have a **fixed length**, so once they're created, we can't add new elements to them. Fortunately, Go also includes a resizable type known as [slice](https://go.dev/ref/spec#Slice_types). For example:

<Code code={sliceCode} lang="go" title="slices1/main.go" />

Here we have created an **array** of 7 integers but only have initialized 4 of them. Then we have created a **slice** out of that array.

<Admonition title='About Slicing'>
To create a slice we use the general syntax: `a[m:n]`, where:

- `a` represents the array where taking the slice from.
- `m` is the **start element** (inclusive), in other words the array index which our slice is referencing.
- `n` is the **end index** (exclusive), which is determined by the length of the array (can't go further the last array element).

The **length** of the resulting slice is `n - m`.

</Admonition>

Several things to notice in the code above:

- Notice how Go has zeroed the values of the array we didn’t initialized.
- The functions `len()` and `cap()` return the same value in the case of the **array**, its **length**.
- But in the case of the **slice**, the **length** and **capacity** are different.

To understand that, we have to dig a bit deeper in what a slice really is.

## Slice internals

A slice always refer to an underlying array, but it's not just a **pointer**.
The documentation refers to slices as **descriptors**. A slice is a small data structure holding three pieces of information. The following diagram illustrates the slice of our last example:

<Picture
  src={sliceHeader}
  alt="Slice Header"
  pictureAttributes={{ style: 'background-color: gray;' }}
/>

This small data structure it’s also known as the **slice header**, an contains 3 parts:

- A **pointer** (aka reference) to the element of the underlying array where the slice starts (the `m` in `s[m:n]`).
- The **length** is the number of array elements that our slice is referencing. We can reassign values to the elements of the slice inside its length range, but it we try to do it outside it, we’ll get a `panic: runtime error`.
- The **capacity** of the slice is the distance between the first element of the slice and the last element of the array. That means that the **capacity** of the **slice** is determined by the **length** of the underlying **array**.

<Admonition>
  The **capacity** is the _potential amount of elements_ that a **slice** can
  have. In the last example the slice had `3` elements, but it may have had `5`.
</Admonition>

## Creating slices

There are several ways to create a slice:

- **Slicing** an array (what we did in our last example).
- **Slicing** another slice.
- Declaring and initializing a slice.

### Slicing an array

Slicing is done using **2 indices** separated by a **colon** inside the **square brackets**, which is known as a [slice expression](https://go.dev/ref/spec#Slice_expressions):

```
s[m:n]
```

The above expression takes a slice from index `n` to `m - 1` (up to `m`, but not included). The following table shows the slicing operations available in Go:

| Syntax   | Description/result                             |
| :------- | :--------------------------------------------- |
| `a[m:n]` | A new slice from index `m` to index `n - 1`    |
| `a[:n]`  | A new slice from index `0` to `n - 1`          |
| `a[m:]`  | A new slice from index `m` to maximum capacity |
| `a[:]`   | A new slice from index `0` to maximum capacity |

The last two **slice expressions** create slices that extends as far as possible in the array. This is equivalent to `a[:len(a)]` or `a[:cap(a)]`, since in arrays the **length** and the **capacity** are the same.

### Slicing a slice

We can create a slice by slicing an existing slice; the result will be another slice that references the same array. For example, let’s use our last example and create a second slice out of the first one:

<Code code={sliceCode2} lang="go" title="slices2/main.go" />

Above we have:

- Created an array with 7 integers.
- Created slice `s1` by slicing the array.
- Created the slice `s2` out of the slice `s1`.

Both slices are referencing the same array. Notice how we have used the capacity of the `s1` in our slicing operator to create `s2` with a length that extends to its **full capacity**. Check the following diagram:

<Picture
  src={slicingSlices}
  alt="Slicing slices"
  pictureAttributes={{ style: 'background-color: gray;' }}
/>

The length of `s2` is at its maximum, the length of a slice can never be bigger than its capacity. Every time we re-slice, the resulting slice will have the same capacity as the original slice, since both of their pointers are directed at the same array. In other words, we can change only the length field, but always within the capacity limits.

<Admonition>
  Because slices are just **references**, re-slicing operations do not copy any
  data from the original slice they just create new descriptors that point to
  different areas of the **original array**.
</Admonition>

### Declaring Empty and Nil Slices

We can create slices without using the **slicing operations** on arrays or other slices. For example, the code belows declares a slice:

<Code code={sliceCode3} lang="go" title="slices3/main.go" />

In the code above we've created an **empty array** and an **empty slice**. In both cases they print `[]`, but if we use [reflect]() package, we can see that:

- **Arrays** are typed as `[n]T`, where `n` is the length (in this case `0`) and `T` the type.
- **Slices** are typed as `[]T`, where `T` is the type. Even if the slice is not `nil` or empty, the type will be `[]T`.

Note that, in the last line our slice is marshalled as `null`; that's because we're dealing with a `nil` slice. In order to create an **empty slice**, we have to use a **composite literal**:

<Code code={sliceCode4} lang="go" title="slices4/main.go" />

<Admonition title="Nil vs Empty">
The main difference between `nil` and **empty** slices, it's that `nil` slices are **not initialized**, meaning that no underlying array exists!

To expand a **not initialized** slice you can use `append` (since it creates an underlying array) but never a **slicing operation**, otherwise you'd get a panic error.
</Admonition>

Creating **empty slices** is extremely common in Go, it's a core idiom for handling collections that start empty but may grow (e.g., via `append`). For example:

<Code code={sliceCode6} lang="go" title="slices6/main.go" />

By the way, you can create an **empty slice** from an **empty array**:

```go
a := [...]byte{}
s := a[:]
```

You can also create an **empty slice** using the `make` built-in function:

<Code code={sliceCode7} lang="go" title="slices7/main.go" />

This function allows us to create a slice specifying its length. At the same time, it creates the underlying array, that's why the **length** and **capacity** of the slice are the same, because `make()` created an array big enough to accommodate our slice size. That's why the slice items are initialized to their zero values.

<Admonition>
If we want to create a bigger underlying array, we have to use the **optional third argument**.
</Admonition>

### Initializing Slices: Composite literals

Whenever we are dealing with a small amount of elements which we know beforehand, we could specify the items:

<Code code={sliceCode5} lang="go" title="slices5/main.go" />


## Slices are resizable

Slices are **resizable**, meaning that we can extend the size of a slice to its full capacity, but not more. We could do that by creating another slice:

<Code code={sliceCode8} lang="go" title="slices8/main.go" />

The code above uses slicing to extend a slice, which still refers to the same array. But what if we need to extend a slice beyond the capacity limit?

<Code code={sliceCode9} lang="go" title="slices9/main.go" />

The [append](https://pkg.go.dev/builtin#append) built-in function will append elements to the end of a slice:

- If it has sufficient capacity, the destination is resliced to accommodate the new elements.
- If it does not, a **new underlying array** will be allocated.

## Slices are references

A **slice** is always a **reference** to an underlying **array**, which means that changes in the values of the **slice** elements will change the values in the **array** and viceversa. For example:

<Code code={sliceCode10} lang="go" title="slices10/main.go" />

In the example above, we create a slice `s1` out of the array `a`. As you can see, changes to the elements of `s1` reflect on the elements of `a`. The same happens with `s2`; both slices refer to the same array.

## Other Useful stuff about Slices

Check these interesting articles about how slices work:

- Like [this one](http://blog.golang.org/go-slices-usage-and-internals) from the golang official blog
- Or [this one](https://blog.golang.org/slices)
- Check also [this one](http://www.goinggo.net/2013/08/understanding-slices-in-go-programming.html) about a function for inspecting the slice header
- Also [slice tricks](https://github.com/golang/go/wiki/SliceTricks)
