import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'
import { Image, Picture } from 'astro:assets'
import sliceCode11 from './code/slices11/main.go?raw'
import sliceCode12 from './code/slices12/main.go?raw'
import sliceCode5 from './code/slices5/main.go?raw'
import sliceCode13 from './code/slices13/main.go?raw'
import sliceCode14 from './code/slices14/main.go?raw'

import sliceCode from './code/slices/main.go?raw'
import sliceCode2 from './code/slices2/main.go?raw'
import sliceCode3 from './code/slices3/main.go?raw'
import sliceCode4 from './code/slices4/main.go?raw'
import sliceCode6 from './code/slices6/main.go?raw'
import sliceCode7 from './code/slices7/main.go?raw'
import sliceCode8 from './code/slices8/main.go?raw'
import sliceCode9 from './code/slices9/main.go?raw'
import sliceCode10 from './code/slices10/main.go?raw'
import sliceHeader from './images/slice_header.png'
import slicingSlices from './images/slicing_slices.png'
import sliceDescriptor2 from './images/slice_descriptor_2.png'

# Slices

In the previous section we saw how **arrays** have a **fixed length**, so once they're created, we can't add new elements to them. Fortunately, Go also includes a resizable type known as [slice](https://go.dev/ref/spec#Slice_types).

## Creating Slices

There are several ways of creating a slice, but let's start with the standard `var` syntax:

<Code code={sliceCode11} lang="go" title="slices11/main.go" />

In the code above:

- We use the `var` keyword to declare a variable of type `[]string` (a slice of strings). 
- Then we use the [append](https://pkg.go.dev/builtin#append) built-in function to add string items to the slice.
- Finally we print the slice and its length using the [len](https://go.dev/ref/spec#Length_and_capacity) built-in function.

<Admonition>
Declaring a **slice** is basically like declaring an **array**, the only difference is the missing length (or the automatic length operator, `...`) between the square brackets.
</Admonition>

We can also create slices using **short syntax** in combination with [composite literal](https://go.dev/ref/spec#Composite_literals):

<Code code={sliceCode12} lang="go" title="slices12/main.go" />

In the code above, we're starting with an **empty slice**, and adding elements according to our needs (an extremely common pattern in Go). In those cases where we start with a small amount of elements which are known beforehand, we could also specify them in the composite literal:

<Code code={sliceCode5} lang="go" title="slices5/main.go" />

<Admonition type="tip" title="Multiline Composite Literals">
  The same as with arrays, we can break up the assignments in several lines.
</Admonition>

## Empty Slices vs Nil Slices

So far we've seen how we can create slices using `var` syntax and the short syntax. Let's write some code to compare both approaches:

<Code code={sliceCode13} lang="go" title="slices13/main.go" />

Note that in both cases the slices print as `[]`, and their length is `0`, but there are some differences:

- When we use the `var` syntax, we end up with a `nil` slice, which means that our slice is **not initialized** (we'll see what this means in a second). Also, when we marshall such a slice, the resulting value is `null`.
- On the other hand, when we use the short syntax, we end up with an **empty slice**, which once converted to JSON, appears as `[]`.

## Slices are References to Arrays

A **slice** is always a **reference** to an underlying **array**, which means that changes in the values of the **slice** elements will change the values in the **array** and viceversa. For example:

<Code code={sliceCode10} lang="go" title="slices10/main.go" />

In the example above, we create a slice `s1` out of the array `a`. As you can see, changes to the elements of `s1` reflect on the elements of `a`. The same happens with `s2`; both slices refer to the same array.

<Admonition title="Nil vs Empty">
The main difference between `nil` and **empty** slices, it's that `nil` slices are **not initialized**, meaning that no underlying array exists!
</Admonition>

When creating slices using the `make` built-in function, the relationship with the underlying array may be not obvious. For example:

<Code code={sliceCode7} lang="go" title="slices7/main.go" />

This function allows us to create a slice specifying its **length**. At the same time, it creates the underlying array, that's why the **length** and **capacity** of the slice are the same, because `make()` created an array big enough to accommodate our slice size. That's why the slice items are initialized to their zero values.

<Admonition>
  If we want to create a bigger underlying array, we have to use the **optional
  third argument**.
</Admonition>

The same happens when we create slices using **short syntax**; this syntax implicitly creates the underlying array for us big enough to hold the specified items (that's why the **length** and **capacity** of slices created this way will always be the same).


## Slicing Expressions

In the previous example we use a strange syntax to create a slice out of an array:

```go
s1 := a[:]
```

The line above creates a slice using what it's known as a [slice expression](https://go.dev/ref/spec#Slice_expressions). The general form of a slice expression is as follows:

```
a[m:n]
```

In the line above:

- `a` stands for the array (or the slice) we want to take the slice from.
- The `m` to the left of the `:` represents the initial index we want to include in our slice.
- The `n` to the right of the `:` represents the right boundary we want to slice.

<Admonition title='Slice Expressions'>
Slicing is done using **2 indices** separated by a **colon** inside **square brackets**: `s[m:n]`.
</Admonition>

In other words, the above expression takes a slice from index `m` to `n - 1` (up to `n`, but not included). The following table shows the slicing operations available in Go:

| Syntax   | Description/result                             |
| :------- | :--------------------------------------------- |
| `a[m:n]` | A new slice from index `m` to index `n - 1`    |
| `a[:n]`  | A new slice from index `0` to `n - 1`          |
| `a[m:]`  | A new slice from index `m` to maximum capacity |
| `a[:]`   | A new slice from index `0` to maximum capacity |

The last two **slice expressions** create slices that extends as far as possible to the right in the target (array or slice).

## Slice internals

A slice always refer to an underlying array, but it's not just a **pointer**. The documentation refers to slices as **descriptors**. A slice is a small data structure holding three pieces of information. The following diagram illustrates the slice of our last example:

<Picture
  src={sliceHeader}
  alt="Slice Header"
  pictureAttributes={{ style: 'background-color: gray;' }}
/>

This small data structure it’s also known as the **slice header**, an contains 3 parts:

- A **pointer** (aka reference) to the element of the underlying array where the slice starts (the `m` in `s[m:n]`).
- The **length** is the number of array elements that our slice is referencing. We can reassign values to the elements of the slice inside its length range, but it we try to do it outside it, we’ll get a `panic: runtime error`.
- The **capacity** of the slice is the distance between the first element of the slice and the last element of the array. That means that the **capacity** of the **slice** is determined by the **length** of the underlying **array**.

<Admonition>
  The **capacity** is the _potential amount of elements_ that a **slice** can
  have. In the last example the slice had `3` elements, but it may have had `5`.
</Admonition>

## Slicing other Slices

We can create a slice by slicing an existing slice; the result will be another slice that references the same array. For example, let’s use our last example and create a second slice out of the first one:

<Code code={sliceCode2} lang="go" title="slices2/main.go" />

Above we have:

- Created an array with 7 integers.
- Created slice `s1` by slicing the array.
- Created the slice `s2` out of the slice `s1`.

Both slices are referencing the same array. Notice how we have used the capacity of the `s1` in our slicing operator to create `s2` with a length that extends to its **full capacity**. Check the following diagram:

<Picture
  src={slicingSlices}
  alt="Slicing slices"
  pictureAttributes={{ style: 'background-color: gray;' }}
/>

The length of `s2` is at its maximum, the length of a slice can never be bigger than its capacity. Every time we re-slice, the resulting slice will have the same capacity as the original slice, since both of their pointers are directed at the same array. In other words, we can change only the length field, but always within the capacity limits.

<Admonition>
  Because slices are just **references**, re-slicing operations do not copy any
  data from the original slice they just create new descriptors that point to
  different areas of the **original array**.
</Admonition>

## Array Type vs Slice Type

Arrays and slices are quite similar, the main difference being that arrays are **value types**, and slices are **reference types**. Let's use the [reflect](https://pkg.go.dev/reflect) package to examine the types:

<Code code={sliceCode3} lang="go" title="slices3/main.go" />

In the code above we've created an **empty array** and an **empty slice**. In both cases they print `[]`, but thanks to the `reflect` package, we can see that:

- **Arrays** are typed as `[n]T`, where `n` is the length (in this case `0`) and `T` the type.
- **Slices** are typed as `[]T`, where `T` is the type. Even if the slice is not `nil` or empty, the type will be `[]T`.

<Admonition title="Length of a Slice not part of its Type">
  Remember when we mentioned in the section about **arrays**, that the length of
  an array it's part of its type? Well, in the case of **slices**, their
  **length** it's not part of their type.
</Admonition>

---

## Sorting and Traversing Slices

Let's look at a couple of basic operations we may want to do with slices. Lets' start with sorting:

<Code code={sliceCode14} lang="go" title="slices14/main.go" />

In this case we're dealing with strings, hence the use of the `StringsAreSorted` method, but feel free to check out the [sort](https://pkg.go.dev/sort) package (part of the standard library) to see the available methods for sorting other types. 

Traversing slices is really simple with a `for` loop and the `range`:

```go
	for i, n := range names {
		fmt.Println(i, n)
	}
```

## Deleting From a Slice

Now that we know how slicing operations work, let's use them in a function to delete a slice item by index. The function receives two arguments:

- The slice.
- The index of the item we want to delete.

Then it uses a simple algorithm named **swap and pop**, which consists on swapping the element to delete with the last element, then pop the slice (i.e. delete the last element). This is a **fast** algorithm, wich `O(1)` complexity, since it doesn't shift the elements in the slice to preserve order. The only con is exactly that, it doesn't preserve order, that's why it's also known as **unordered delete**:

```go
func DeleteByIndex(s []string, i int) []string {
	lastIndex := len(s) - 1
	lastElement := s[lastIndex]
	
	// Move last element to the position we want to delete
	s[i] = lastElement
	
	// Clear the last position (avoid memory leak for string)
	s[lastIndex] = ""
	
	// Shrink slice by removing last element
	s = s[:lastIndex]
	
	return s
}
```

<Admonition type="tip">
If order is important, you could sort the slice before returning it, or do it in the caller, once the new slice is returned (obviously).
</Admonition>

---

<Code code={sliceCode} lang="go" title="slices1/main.go" />

Here we have created an **array** of 7 integers but only have initialized 4 of them. Then we have created a **slice** out of that array.

<Admonition title='About Slicing'>
To create a slice we use the general syntax: `a[m:n]`, where:

- `a` represents the array where taking the slice from.
- `m` is the **start element** (inclusive), in other words the array index which our slice is referencing.
- `n` is the **end index** (exclusive), which is determined by the length of the array (can't go further the last array element).

The **length** of the resulting slice is `n - m`.

</Admonition>

Several things to notice in the code above:

- Notice how Go has zeroed the values of the array we didn’t initialized.
- The functions `len()` and `cap()` return the same value in the case of the **array**, its **length**.
- But in the case of the **slice**, the **length** and **capacity** are different.

To understand that, we have to dig a bit deeper in what a slice really is.




### Declaring Empty and Nil Slices

We can create slices without using the **slicing operations** on arrays or other slices. For example, the code belows declares a slice:

<Code code={sliceCode3} lang="go" title="slices3/main.go" />





Note that, in the last line our slice is marshalled as `null`; that's because we're dealing with a `nil` slice. In order to create an **empty slice**, we have to use a **composite literal**:

<Code code={sliceCode4} lang="go" title="slices4/main.go" />


To expand a **not initialized** slice you can use `append` (since it creates an underlying array) but never a **slicing operation**, otherwise you'd get a panic error.


Creating **empty slices** is extremely common in Go, it's a core idiom for handling collections that start empty but may grow (e.g., via `append`). For example:

<Code code={sliceCode6} lang="go" title="slices6/main.go" />

By the way, you can create an **empty slice** from an **empty array**:

```go
a := [...]byte{}
s := a[:]
```


## Slices are resizable

Slices are **resizable**, meaning that we can extend the size of a slice according to our needs. When doing so, there are two posible scenarios:

- Resizing the slice respecting its capacity (the resulting slice refers to the same array).
- Extending the slice further, which means that a new underlying array must be created (in other words, the resulting slice won't be a reference to the original array).

Using **slicing expressions** we can only resize a slice within its capacity, meaning that the resulting slice will refer to the original array:

<Code code={sliceCode8} lang="go" title="slices8/main.go" />

But when we extend a slice using the [append](https://pkg.go.dev/builtin#append) built-in function, the resulting slice may or may not refer to the original array:

- If it has sufficient **capacity**, after the extension, the slice will still refer to the original array.
- But if we append elements above the slice capacity, a **new underlying array** will be allocated.

<Code code={sliceCode9} lang="go" title="slices9/main.go" />

In the example above, we can see how `s1` refers to the original array, whereas `s2` does not.

## Other Useful stuff about Slices

Check these interesting articles about how slices work:

- Like [this one](http://blog.golang.org/go-slices-usage-and-internals) from the golang official blog
- Or [this one](https://blog.golang.org/slices)
- Check also [this one](http://www.goinggo.net/2013/08/understanding-slices-in-go-programming.html) about a function for inspecting the slice header
- Also [slice tricks](https://github.com/golang/go/wiki/SliceTricks)
