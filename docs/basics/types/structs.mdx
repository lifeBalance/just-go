import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'
import { Image, Picture } from 'astro:assets'

# Structs

A [struct](https://go.dev/ref/spec#Struct_types) is a composite data type that groups together variables (fields) under a single name. They're used in different scenarios:

- Grouping related data together
- Creating custom types with methods
- Modeling real-world entities (User, Product, Order, etc.)
- Passing multiple values as a single unit
- Building data structures (linked lists, trees, etc.)

## Declaring Structs

Let's declare a `person` variable of the type `struct`:

```go
var person struct {
		name string
		age  int
}

fmt.Printf("%#v\n", person) // struct { name string; age int }{name:"", age:0}
```

We have to use [Printf]() with the right **format specifier** to see what the struct is about. As you may have guessed, structs are **values** in Go. The `person` declaration above creates a struct where each **field** is set to its own **zero value** (`""` for strings, `0` for ints).

## Declaring and Initializing

We can declare and Initialize a struct in one go, using [composite literal](https://go.dev/ref/spec#Composite_literals) syntax:

```go
var person struct {
		name string
		age  int
}{
    name: "Bob",
    age: 42,
}

fmt.Println(person.name) // Bob
fmt.Println(person.age) // 42
```

And we can also use a **short syntax**:

```go
person := struct {
		name string
		age  int
}{
    name: "Bob",
    age: 42,
}

fmt.Println(person.name) // Bob
fmt.Println(person.age) // 42
```

<Admonition title="Anonymous Struct">
  This type of on-the-fly `struct` are known as **anonymous structs**.
</Admonition>

As you can see, we can access struct fields using **dot notation**; we can also use the same syntax for updating its fields:

```go
person := struct {
		name string
		age  int
}{
    name: "Bob",
    age: 42,
}

person.name = "Ralphie"
person.age = 33

fmt.Println(person.name) // Ralphie
fmt.Println(person.age)  // 33
```

Trying to access a **non-existing field** (for reading or updating) would result in an error:

```go
fmt.Println(person.surname) // ‚ùå type struct{name string; age int} has no field or method surname
```

## Defining Struct Types

Most of the times, we'll want to define `struct` types that we can reuse throughout our code:

```go
type Person struct {
    name string
    age  int
}
```

<Admonition>
  Note how we're using uppercase `Person` here, to export the type, so we can
  reuse it in other packages. It doesn't have to be always like this, some types
  may not be needed in other packages.
</Admonition>

To create instances of `Person` we would do:

```go
var p1 Person

fmt.Printf("%#v\n", p1) // struct { name string; age int }{name:"", age:0}
```

We can initialize the fields of an instance using **positional values** or **named values**:

```go
var p1 Person

p2 := Person{"Alice", 30, "NYC"}            // Positional
p3 := Person{name: "Bob"}                   // Named (can omit fields)
p4 := Person{age: 40, name: "Charlie"}      // Field order doesn't matter
```

## Comparing Structs

Structs are **comparable** if all their fields are comparable:

```go
type Point struct {
    x, y int
}

p1 := Point{1, 2}
p2 := Point{1, 2}
p3 := Point{3, 4}

fmt.Println(p1 == p2)  // ‚úÖ true
fmt.Println(p1 == p3)  // ‚ùå false
```

## Pointers to Structs

If structs are **values**, how can we pass them to functions to modify them?

```go
p := Person{name: "Alice", age: 30}

func increaseAge(someone &Person) {
    someone.age++
    fmt.Printf("Someone just turned %d!\n", (*someone).age) // Explicit dereferencing (not needed)
    fmt.Printf("Someone just turned %d!\n", someone.age) // Go automatically dereferences
}

fmt.Printf("Alice is %d years old.\n", p.age)
```

## Embedded Structs (Composition)

Go doesn't have inheritance, but you can embed structs:

```go
type Address struct {
    street string
    city   string
}

type Employee struct {
    name    string
    age     int
    address Address
}

e := Employee{
    name: "Alice",
    age:  30,
    address: Address{
        street: "123 Main St",
        city:   "NYC",
    },
}

fmt.Println(e.address.street)   // "123 Main St"
fmt.Println(e.address.city) 	// "NYC"
```

## Explicit fields vs Implicit fields

There are two ways of specifying fields in structs:

- Explicitly using **unique names**.
- Implicitly using **embedded types** without an explicit name.

We've been seeing explicit fields from the beginning:

```go
type Address struct {
    street string
    city   string
}

type Employee struct {
    name    string
    age     int
    Address // üëà Embedded field (no explicit name)
}

e := Employee{
    name: "Alice",
    age:  30,
    address: Address{
        street: "123 Main St",
        city:   "NYC",
    },
}

// Access embedded field by type.name
fmt.Println(p.Address.city)  // "NYC"

// OR access embedded fields directly
fmt.Println(p.city)    // "NYC" (field promotion)
fmt.Println(p.street)  // "123 Main St"
```

There are some rules when using embedded fields:

1. Type name is the field name:

```go
type Employee struct {
    Person  // Field name is "Person"
    salary int
}

e := Employee{}
e.Person.name = "Bob"   // Access via type name
e.name = "Bob"          // Or directly
```

2. Can embed pointers:

```go
type Employee struct {
    *Person  // Field name is "Person"
    salary   int
}
```

3. Field promotion - embedded fields' members are **promoted**:

```go
type Person struct {
    name string
}

type Employee struct {
    Person
    id int
}

e := Employee{}
e.name = "Alice"  // Promoted from Person
// Same as: e.Person.name = "Alice"
```

4. Must be **unique** - can't embed the same type twice:

```go
type Bad struct {
    Person  // ‚ùå ERROR: duplicate field Person
    Person
}
```

## Adding Behaviour

There are two main ways to add behavior to structs: function fields and methods.

### Function Fields

Apart from grouping related data, struct fields can also store function values, allowing us to add behavior to our structs:

```go
func sayHi(name string) {
	fmt.Printf("Hi, I'm %s\n", name)
}

func sayBye(name string) {
	fmt.Printf("%s is out!\n", name)
}

type Person struct {
    name  string
    age   int
    greet func(string)
}


func Main() {
    p := Person{name: "Bob", age: 42, greet: sayHi}

    p.greet(p.name) // Hi, I'm Bob

    p.greet = sayBye // Change behavior

    p.greet(p.name) // Bob is out!
}
```

The **function-field pattern** is fine when you literally want **per-instance behavior** that callers can swap out (e.g., dependency injection, test doubles, runtime strategy selection). It‚Äôs more flexible but also more explicit: each instance carries a function pointer you must remember to set.

#### DI Example

The **function-field pattern** should only be used in particular scenarios ‚Äî for example, if consumers should be able to **inject** their own logger or callback per instance. For example:

```go
type Thing struct {
	Log func(string)
}

func (t Thing) DIDemo() {
	logFn := t.Log          // Check for injected logger
	if logFn == nil {       // Fallback to default
		logFn = func(msg string) {
			log.Println(msg)
		}
	}
	err := doThing()
	if err != nil {
		logFn(fmt.Sprintf("failed to do the thing: %v", err))
		return
	}
	// pretend to keep going
}
```

Callers can now inject whatever logger they want:

```go
func Main() {
    custom := Thing{
        Log: func(msg string) {
            fmt.Println("API logger:", msg)
        },
    }
    custom.DIDemo() // logs through the injected callback
}
```

In the next section, we'll look at the **idiomatic Go way** to add behavior to structs.

### Methods

Go‚Äôs idiomatic way to hang behavior on a struct is known as the [receiver syntax](https://go.dev/ref/spec#Method_declarations). Here‚Äôs how we can rewrite the previous example using this syntax:

```go
type Person struct {
    name string
    age  int
}

func (p Person) greet(greeting string) {
    fmt.Printf("%s %s", greeting, p.name)
}

func Main() {
    p := Person{name: "Bob", age: 42}

    p.greet("What's up! I'm")       // What's up! I'm Bob
    p.greet("Hello, my name is")    // Hello, my name is Bob
}
```

The big win is ergonomics: **methods** automatically have access to the struct‚Äôs fields, so you don‚Äôt have to pass `name`, `age`, and everything else as arguments every time.

<Admonition title="Receiver">
  In the example above, the receiver is `(p Person)`, a **value** of the type
  `Person`.
</Admonition>

If we want to modify the struct inside the method, we can use a **pointer receiver**:

```go
func (p *Person) haveBirthday() {
    p.age++ // Modify the age field
    fmt.Printf("Happy birthday %s! You are now %d years old.\n", p.name, p.age)
}
```

#### Type of Methods

Struct methods can have either **value receivers** or **pointer receivers**. Let's see another example with a `Rectangle` struct that has methods to calculate the area and scale its size:

```go
type Rectangle struct {
    width  float64
    height float64
}

// Method with value receiver
func (r Rectangle) Area() float64 {
    return r.width * r.height
}

// Method with pointer receiver (can modify)
func (r *Rectangle) Scale(factor float64) {
    r.width *= factor
    r.height *= factor
}

func Main() {
    rect := Rectangle{width: 10, height: 5}

    fmt.Println(rect.Area())  // 50
    rect.Scale(2)
    fmt.Println(rect.Area())  // 200
}
```
