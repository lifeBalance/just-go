import Admonition from '@components/Admonition.astro'

# String Manipulation

String manipulation is ubiquitous in Go â€” parsing input, formatting messages, building URLs, handling JSON, and talking to APIs. This section focuses on practical string operations and patterns.

<Admonition  title="Rune Type">
For the fundamentals of the `string` type see the Types chapter about [Strings](../types/strings), where we cover things like:

    - String as byte sequences and intended use.
    - String literals.
    - Immutability.
    - Accessing characters and length.
    - UTF-8 encoding and escape sequences.

</Admonition>

## Basic Operations

Let's start with some basic operations you can perform on strings in Go. Check the [strings package documentation](https://pkg.go.dev/strings) for many more useful functions.

### Concatenation

There are multiple ways to concatenate strings in Go.

1. Use `+` for **simple concatenation**:

```go
s1 := "Hello, "
s2 := "Gopher"
s := s1 + s2 // "Hello, Gopher"
```

2. Use `fmt.Sprintf` for formatted concatenation:

```go
import "fmt"

s1 := "Hello, "
s2 := "Gopher"
s := fmt.Sprintf("%s%s", s1, s2) // "Hello, Gopher!"
```

## Efficient String Concatenation

In Go, strings are **immutable**. When you concatenate strings using the `+` operator, a new string is created, and the contents of both strings are copied into the new string.

If you are building a string in a loop by concatenating, you are creating a new string in each iteration, and the entire string built so far is copied again and again. For example, suppose we have a loop that concatenates a small string in each iteration:

```go
s := ""
for i := 0; i < 1000; i++ {
    s += "x"
}
```

Let's see what happens in each iteration:

- Iteration 1: `s = "a"` (copied 1 character)
- Iteration 2: `s = "aa"` (copied 2 characters)
- Iteration 3: `s = "aaa"` (copied 3 characters)
- ...
- Iteration `n: s = "a...a"` (copied n characters)

The total number of characters copied is `1 + 2 + 3+ ... + n = n(n + 1) / 2`, which is `O(n^2)` or quadratic.

In contrast, `strings.Builder` uses a buffer (a slice of bytes) that grows in a way that minimizes copies. Typically, it grows by doubling the capacity when needed, which results in `O(n)` time for building the string.

```go
import "strings"

var sb strings.Builder

for i := 0; i < n; i++ {
    sb.WriteString("a")
}

s := sb.String()
```

<Admonition type="tip" title="When to use Builder">
  Use `strings.Builder` (or `bytes.Buffer`) when concatenating in loops or
  building large strings incrementally.
</Admonition>

### Changing the Case

Changing the case of a string is quite common, [ToUpper](https://pkg.go.dev/strings#ToUpper) and [ToLower](https://pkg.go.dev/strings#ToLower) get the job done:

```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println(strings.ToUpper("Gopher")) // GOPHER
	fmt.Println(strings.ToLower("Gopher")) // gopher
}
```

### Trimmming Strings

Trimmming strings is quite useful in several scenarios, such as getting rid of whitespace before doing a search:

```go
strings.TrimSpace("  x ") // "x"
strings.Trim("--x--", "-") // "x"
```

### Substring Search

To search for substrings, the [strings](https://pkg.go.dev/stringshttps://pkg.go.dev/strings#pkg-functions) package offers several functions:

- [Contains](https://pkg.go.dev/strings#Contains) will check for the substring anywhere in the string.
- [HasPrefix](https://pkg.go.dev/strings#HasPrefix) will check for the substring at the **beginning** of the string.
- [HasSuffix](https://pkg.go.dev/strings#HasSuffix) will check for the substring at the **end** of the string.
- [Index](https://pkg.go.dev/strings#Index) returns the index of the first occurrence of a substring, or `-1` if not found.

```go
import "strings"

s := "Go gophers"
strings.Contains(s, "go")           // false (case sensitive)
strings.Contains(strings.ToLower(s), "go") // true
strings.HasPrefix(s, "Go")          // true
strings.HasSuffix(s, "phers")       // true
strings.Index(s, "ph")              // 4
```

The functions above are **case-sensitive**, so it's common to combine them with some casing function, such as `strings.ToLower` or `strings.ToUpper`.

#### Removing a Substring at a Particular Location

We can combine the `Index` function with a **slicing expression** to remove a substring at a particular location:

```go
import "strings"

// Remove by index (one occurrence)
text := "alpha beta gamma"
needle := "beta "

if i := strings.Index(text, needle); i >= 0 {
    text = text[:i] + text[i+len(needle):] // "alpha gamma"
}
```

Since strings are **inmutable**, `text` ends up pointing to a **new strings**.

### Split and join

Splitting strings is a workhorse when dealing with CSV data:

```go
parts := strings.Split("a,b,c", ",") // ["a","b","c"]

// Do some operations, then join back

joined := strings.Join(parts, ";")    // "a;b;c"
```

The result of [Split](https://pkg.go.dev/strings#Split) is an array of strings, which can be then joined back with the [Join](https://pkg.go.dev/strings#Join) function. This last function simply concatenates the strings if we use an **empty separator**:

```go
import "strings"

parts := []string{"Hello", "Gopher"}

s := strings.Join(parts, "") // "HelloGopher"
```

Use `strings.Join` for joining the items in strings array with a separator:

```go
import "strings"
parts := []string{"Hello", "Gopher"}
s := strings.Join(parts, ", ") // "Hello, Gopher"
```

If we use an **empty separator**, it simply concatenates the strings:

```go
s := strings.Join(parts, "") // "HelloGopher"
```

We could use these two functions in tandem to **remove all occurrences** of a substring:

```go
import "strings"

parts := strings.Split("foo-bar-baz-bar", "-bar")

result := strings.Join(parts, "") // "foobaz"
```

In the next section we'll see an easier way.

### Replacing Strings

To [Replace]() the **first occurrence** of a substring:

```go
import "strings"

s := "hello, gopher! hello again"

first := strings.Replace(s, "hello", "see you", 1)   // "see you, gopher! hello again"
```

And if we want to replace all occurrences:

```go
import "strings"

s := "hello, gopher! hello again"

all := strings.ReplaceAll(s, "hello", "hi")     // "hi, gopher! hi again"
```

We could use these two functions to **remove** substrings by passing an **empty string** as a second argument.
