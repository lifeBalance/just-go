import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'
import mainGo from './code/myapp/main.go?raw'

# Packages and Modules

Go programs are written by linking together [packages](https://go.dev/ref/spec#Packages). A package is just a **folder** containing one or several `.go` source files that share the same `package` name. 

<Admonition type='warning'  title='A Package per Folder'>
Folders work as **package boundaries**, so it's not a good idea to place several packages in the same folder. The rule is to place a package in its own folder.
</Admonition>

The purpose of using packages is to organize our code, so that we don't get names clashing with each other. Using packages, we could have two functions with the same name, but under a different package. In that sense, a package is like a namespace (`utils.DoSomething` will not clash with `lib.DoSomething`).

## A Small App

For example, let's create a folder named `myapp` where we'll initialize a module. Our tiny app looks like this:

```
myapp/
    ├── go.mod
    ├── main.go             # package main (executable)
    ├── lib/                
    |   └── utils.go        # package lib (library code)
    └── utils/
        └── utils.go        # package utils (library code)
```

<Admonition  title='Files can be named whatever'>
Inside our package folders, we can name our source files whatever we want. For example, in this case both `lib` and `utils` folders contain a file named `utils.go`. That's fine, it's the **name** that we use in our `package` declarations what matters.
</Admonition>

This is what our our `main.go` looks like:

<Code code={mainGo} lang='go' title='myapp/main.go'/>

A couple things to highlight here:

- Note that we import our packages using the `<module-path>/<package>` syntax, e.g. `myapp/utils`.
- Even though we're using a couple of homonymous function calls, we don't get any error, since each function lives in a different package.

To compile and run this program, we would execute from the module folder (where `go.mod` lives):

```bash
go run .
```

In this case, `myapp` is a program intended to be **executable**, so it needs of a single `package main` declaration. Since this is a **small program**, we don't need a `main` folder to keep our `main` package. A single file `main.go` is enough in this case.

## Bigger Programs

In bigger programs, we may need to create a dedicated `main` folder for our `main` package (we don’t have to cram everything into `main.go`). For example:

```
biggerapp/
    ├── go.mod
    ├── main/                
    |   ├── flags.go
    |   ├── wire.go
    |   └── main.go     ✅ main function lives here
    ├── config.go
    ├── lib/                
    |   └── utils.go
    └── utils/
        └── utils.go
```

Other programs may build several executables. Convention: use a top‑level `cmd` folder with one subfolder per binary; each subfolder is a `package main`.

```
multipleapp/
    ├── go.mod
    ├── cmd/
    │   ├── server/
    │   │   └── main.go      # package main → builds "server"
    │   └── worker/
    │       └── main.go      # package main → builds "worker"
    ├── internal/            # ❌ Private API
    │   └── greet/
    │       └── greet.go
    └── pkg/                 # ✅ Public API (optional)
        └── utils/
            └── utils.go
```

Each folder under `cmd/` produces a separate binary named after the folder. Keep those `main` packages thin and move reusable code to your packages in `internal/` or `pkg/`.

### Public vs Private API

When publishing a package, we decide what code we want to make available  as library code, for our package users:

- Anything under `internal/` can only be imported by code within the parent directory tree (i.e. within the `multipleapp` folder). In other words, this is shared library code, but not intended to be used by `multipleapp` users. In other words, it's a **private API** boundary.
- Packages under `pkg/` are **public API**, intended for external consumption.

Note that whereas `internal/` is special in Go, `pkg/` is just a convention, with no special meaning. Some teams simply put **public packages** at the module root (`example.com/app/greet`) without a `pkg/` folder.

## Package vs. Module

Hopefully by now, you have a clear understanding of the difference between a [module](https://go.dev/ref/mod) and a [package](https://go.dev/ref/spec#Packages). As a summary:

- **Package**: a unit of code in a single folder (optionally split across several source files).
- **Module**: a collection of packages with dependency/version info in `go.mod`.

A module is the versioned umbrella that contains one or more packages and a single `go.mod` file.

We have to make a difference between:

- **Local packages** are imported using the `<module>/<pkg>` syntax (e.g., `myapp/utils`).
- **Third‑party packages**: use the **full repository path**. For these packages, the `<module>` part can be found in the `require` section in `go.mod`.

Example third‑party import:

```go
import cowsay "github.com/Code-Hex/Neo-cowsay/v2"
```

When a third‑party package reaches a major version, the import path includes `/vN`.

## Common Pitfalls

- Mixed packages in one folder → split into subfolders.
- Unexported helpers (lowercase) cannot be used from `main` → make them uppercase.
- Missing `/vN` in import path for v2+ packages → add the suffix.


## Some Interesting Links

You may find useful information about modules and packages in:

- Packages and imports: https://go.dev/doc/code
- Modules reference: https://go.dev/ref/mod
