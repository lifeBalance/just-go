import Admonition from '@components/Admonition.astro'
import { Code } from 'astro-expressive-code/components'

import errorsCode from './code/errors/main.go?raw'

# Errors

In Go [errors](https://go.dev/ref/spec#Errors) are just **values** that we can return from functions. For example:

<Code code={errorsCode} lang="go" title="functions7/main.go" />

In the example above, `divideTwoNumbers` returns two values:

- A floating point value.
- And an `error`, which could be `nil` if everything went ok.

In the caller, we “destructure” the multiple return values of `divideTwoNumbers`, then check `err`.

<Admonition variant="warning" title="Panic Crash">
If we didn't have the check for `0` quotient, our program will crash when trying to divide by `0`.
</Admonition>

The [errors](https://pkg.go.dev/errors) package contains all that we need for **error management**.

## The Error Checking Pattern

Some folks from exception‑driven languages find this error-checking pattern **repetitive**; in Go it keeps **control flow** obvious and testable:

- Returning `nil` as error signify **success**; otherwise, a non `nil` value indicates **failure**.
- Errors are **values**, you can pass, wrap, compare, or inspect them.
- Prefer simple, actionable **error messages**.

<Admonition variant="tip" title="Multiple return values">
Returning `(T, error)` makes error handling explicit and keeps the happy path straightforward. Callers should check `err` before using the other results.
</Admonition>

