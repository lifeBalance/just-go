# Go URL Shortener with Background Validation

A [URL shortener](https://en.wikipedia.org/wiki/URL_shortening) is a web app, that offers a way to turn a long, messy link into something short and tidy that you can share without breaking layouts or overwhelming people. 

Typical users are social media managers fitting links into post character limits, marketers tracking campaign traffic, support teams sending cleaner links to customers, event planners printing QR codes, or anyone who just wants an easy-to-type URL.

## How to Use It

Using it is simple: 

1. User copy the original long URL.
2. User paste it into the shortenerâ€™s input field. 
3. Submit to generate a **short link**.
4. Share the new short link wherever you need it.

## How It Works

A **short link** would look something like this: 

```
https://sho.rt/abc123
```

When the user clicks on it, it's taken to the **shortener website**, i.e. `https://sho.rt`. There the service:

1. Parses the request, looks up `abc123` in its storage (database, cache, etc.).
2. When it finds the matching **original URL**, immediately replies with an [HTTP redirect](https://en.wikipedia.org/wiki/URL_redirection).
3. When the user's browser receives the response, it automatically redirects the user to the original URL, without noticing the handoff.

## âœ¨ Features

A production-ready URL shortener API that demonstrates advanced Go concurrency patterns, context propagation, and error handling. This is more than a simple key-value storeâ€”it includes background validation, worker pools, and robust error management.

- ğŸ”— Smart URL Shortening: Generate short codes for URLs with customizable lengths
- âœ… Background Validation: Asynchronous URL reachability checks with timeout handling
- âš¡ Concurrent Processing: Worker pool pattern for efficient background validation
- ğŸ›¡ï¸ Context-Aware Operations: Full context propagation for graceful cancellation
- ğŸ§ª Comprehensive Testing: Table-driven tests with race condition detection
- ğŸ“Š Metadata Capture: Optional metadata collection during validation
- ğŸ¯ Precise Error Handling: Wrapped errors with proper HTTP status codes

## ğŸ—ï¸ Project Structure

```sh
urlshortener/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go          # Application entry point
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ handlers.go      # HTTP handlers
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â””â”€â”€ shortener.go     # Business logic
â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â””â”€â”€ memory.go        # In-memory storage
â”‚   â”œâ”€â”€ validator/
â”‚   â”‚   â””â”€â”€ worker.go        # Background validation workers
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ types.go         # Domain types
â”œâ”€â”€ ui/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ errors/
â”‚   â”‚   â””â”€â”€ errors.go        # Custom error types
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ random.go        # Utility functions
â”œâ”€â”€ test/
â”‚   â””â”€â”€ integration_test.go  # Integration tests
â””â”€â”€ go.mod
```

## âš™ï¸ Configuration Options

| Environment Variable   | Default                | Description                    |
| ---------------------- | ---------------------- | ------------------------------ |
| PORT                   | 8080                   | HTTP server port               |
| WORKER_POOL_SIZE       | 5                      | Number of validation workers   |
| VALIDATION_TIMEOUT 30s | URL validation timeout |
| CODE_LENGTH            | 6                      | Short code length              |
| MAX_VALIDATION_WORKERS | 10                     | Maximum concurrent validations |
| CLEANUP_INTERVAL       | 5m                     | Expired URL cleanup interval   |
| MAX_URL_LENGTH         | 2048                   | Maximum URL length             |

Create `.env` file:

```
PORT=8080
WORKER_POOL_SIZE=5
VALIDATION_TIMEOUT=5s
CODE_LENGTH=6
MAX_VALIDATION_WORKERS=10
```

## ğŸ“– API Reference

## Create a new short URL with background validation

- Endpoint: `POST /api/shorten`

- Request body:

```json
{
  "url": "https://example.com",
  "custom_code": "optional",
  "metadata": {
    "source": "mobile-app",
    "user_id": "12345"
  }
}
```

- Response body:

```json
{
  "short_code": "abc123",
  "short_url": "http://localhost:8080/abc123",
  "original_url": "https://example.com",
  "status": "pending_validation",
  "created_at": "2024-01-15T10:30:00Z"
}
```

## Redirect to the original URL.

- Endpoint: `GET /{code}`

- Response codes:
  - 302 Found - Redirects to original URL
  - 404 Not Found - Code doesn't exist
  - 400 Bad Request - URL failed validation

## Get URL information and validation status.

- Endpoint: `GET /api/info/{code}`

- Response body:

```json
{
  "code": "abc123",
  "original_url": "https://example.com",
  "short_url": "http://localhost:8080/abc123",
  "created_at": "2024-01-15T10:30:00Z",
  "validated_at": "2024-01-15T10:30:05Z",
  "is_valid": true,
  "metadata": {
    "source": "mobile-app"
  },
  "clicks": 42
}
```

## Delete a short URL.

- Endpoint: `DELETE /api/{code}`

- Response codes:
  - 204 No Content - Successfully deleted
  - 404 Not Found - Code doesn't exist

## ğŸ¯ Concurrency Patterns

### Worker Pool for Validation

```go
type ValidatorPool struct {
    workers   int
    jobChan   chan validationJob
    ctx       context.Context
    waitGroup sync.WaitGroup
}
```

- Fixed-size worker pool prevents resource exhaustion
- Buffered channel for job distribution
- Graceful shutdown with context cancellation
- WaitGroup ensures all jobs complete on shutdown

### Context Propagation

- HTTP request context flows to background workers
- Timeout and cancellation propagate automatically
- No wasted cycles if client disconnects early

```go
func (s *Service) Shorten(ctx context.Context, req ShortenRequest) (*ShortenResponse, error) {
    // Pass parent context to validation goroutines
    vCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    go s.validator.ValidateAsync(vCtx, req.URL, req.Metadata)
    // ...
}
```

### Error Handling

- Errors.As/Is for precise HTTP status codes
- Structured error wrapping maintains context
- Clean separation between business and transport errors

```go
// Custom error types
var (
    ErrURLNotFound     = errors.New("URL not found")
    ErrInvalidURL      = errors.New("invalid URL")
    ErrValidationFailed = errors.New("validation failed")
)

// Wrapped errors with context
func validateURL(ctx context.Context, url string) error {
    if err := checkReachability(ctx, url); err != nil {
        return fmt.Errorf("failed to validate %s: %w", url, err)
    }
    return nil
}
```

## ğŸ§ª Testing

### Run All Tests

```sh
# Run with race detector
go test -race ./...

# Run with coverage
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# Run integration tests
go test -tags=integration ./test/...
```

### Test Structure

```go
func TestShorten(t *testing.T) {
    tests := []struct {
        name        string
        request     ShortenRequest
        wantErr     bool
        errType     error
        setup       func(*testing.T) *Service
    }{
        {
            name: "valid url",
            request: ShortenRequest{URL: "https://google.com"},
            wantErr: false,
        },
        {
            name: "invalid url",
            request: ShortenRequest{URL: "not-a-url"},
            wantErr: true,
            errType: ErrInvalidURL,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

### Cancellation Tests

```go
func TestShorten_Cancellation(t *testing.T) {
    ctx, cancel := context.WithCancel(context.Background())
    cancel() // Immediate cancellation

    _, err := service.Shorten(ctx, ShortenRequest{
        URL: "https://example.com",
    })

    if !errors.Is(err, context.Canceled) {
        t.Errorf("expected context.Canceled, got %v", err)
    }
}
```
